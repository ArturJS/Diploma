\documentclass[bachelor, och, pract, times]{SCWorks} 
% параметр - тип обучения - одно из значений: 
% spec - специальность 
% bachelor - бакалавриат (по умолчанию) 
% master - магистратура 
% параметр - форма обучения - одно из значений: 
% och - очное (по умолчанию) 
% zaoch - заочное 
% параметр - тип работы - одно из значений: 
% referat - реферат 
% coursework - курсовая работа (по умолчанию) 
% diploma - дипломная работа 
% pract - отчет по практике 
% параметр - включение шрифта 
% times - включение шрифта Times New Roman (если установлен) 
% по умолчанию выключен 
\usepackage[T2A]{fontenc} 
\usepackage[cp1251]{inputenc} 
\usepackage{graphicx} 

\usepackage[sort,compress]{cite} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{fancyvrb} 
\usepackage{longtable} 
\usepackage{array} 
\usepackage[english,russian]{babel} 
\usepackage{tikz} 


\usepackage[colorlinks=false]{hyperref} 

\newcommand{\eqdef}{\stackrel {\rm def}{=}} 

\newtheorem{lem}{Лемма} 

\begin{document} 

% Кафедра (в родительном падеже) 
\chair{математической кибернетики и компьютерных наук} 

% Тема работы 
%\title{Разработка приложения на языке C++ в среде Microsoft VisualStudio} 
\title{Разработка высоконагруженных приложений на языке JavaScript.} 

% Курс 
\course{4} 

% Группа 
\group{411} 

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ") 
%\department{факультета КНиИТ} 

% Специальность/направление код - наименование 
\napravlenie{02.03.02 "-— Фундаментальная информатика и информационные технологии} 
%\napravlenie{010500 "-— Математическое обеспечение и администрирование информационных систем} 
%\napravlenie{230100 "-— Информатика и вычислительная техника} 
%\napravlenie{231000 "-— Программная инженерия} 
%\napravlenie{090301 "-— Компьютерная безопасность} 

% Для студентки. Для работы студента следующая команда не нужна. 
\studenttitle{Студента} 

% Фамилия, имя, отчество в родительном падеже 
\author{Низамутдинов Артура Салаватовича} 

% Заведующий кафедрой 
\chtitle{к.ф.-м.н.} % степень, звание 
\chname{С.~В.~Миронов} 

%Научный руководитель (для реферата преподаватель проверяющий работу) 
\satitle{зав. кафедрой, к.~ф.-м.~н.} %должность, степень, звание 
\saname{С.~В.~Миронов} 

% Руководитель практики от организации (только для практики, 
% для остальных типов работ не используется) 
\patitle{зав. кафедрой, к.~ф.-м.~н.} 
\paname{С.~В.~Миронов} 

% Семестр (только для практики, для остальных 
% типов работ не используется) 
\term{8} 

% Наименование практики (только для практики, для остальных 
% типов работ не используется) 
\practtype{преддипломная} 

% Продолжительность практики (количество недель) (только для практики, 
% для остальных типов работ не используется) 
\duration{4} 

% Даты начала и окончания практики (только для практики, для остальных 
% типов работ не используется) 
\practStart{06.05.2016} 
\practFinish{02.06.2016} 

% Год выполнения отчета 
\date{2016} 

\maketitle 

% Включение нумерации рисунков, формул и таблиц по разделам 
% (по умолчанию - нумерация сквозная) 
% (допускается оба вида нумерации) 
%\secNumbering 


\tableofcontents 

% Раздел "Обозначения и сокращения". Может отсутствовать в работе 
%\abbreviations 

% Раздел "Определения". Может отсутствовать в работе 
%\definitions 

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе. 
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения" 
%\defabbr

% Раздел "Введение"
\intro
В 2009 году Райан Дал после двух лет экспериментирования над созданием серверных веб-компонентов разработал NodeJS.

NodeJS является программной платформой, основанной на разработанном компанией Google JavaScript---движке V8 (транслирующем JavaScript в машинный код), преобразующий JavaScript из узкоспециализированного в язык общего назначения. NodeJS используется преимущественно на сервере, выполняя роль веб-сервера, но кроме этого есть возможность разрабатывать на NodeJS и десктопные приложения (с использованием NW.js, Electron или AppJS  для Windows, Linux и Mac OS)  и даже программировать микроконтроллеры (например, espruino и tessel).

В основе Node.js лежит событийно-ориентированное и асинхронное (или реактивное) программирование с неблокирующим вводом/выводом.

%Целью настоящей работы является приведение примеров, а также сравнение эффективности алгоритмов для нахождения $\nod$ и $\nok$ двух натуральных чисел.

Поставленные задачи:
\begin{itemize}
    \item изучить архитектуру NodeJS;
    \item рассмотреть способы асинхронного обмена данными с сервером с использованием websocket, comet, iframe и jsonp;
    \item сравнить websocket и comet;
    \item реализовать веб-сервер на websocket и comet;
    \item реализовать утилиту для нагрузочного тестирования веб-сервера на websocket и comet;
    \item провести нагрузочное тестирование и сделать выводы.
\end{itemize}

%Также на рисунках 1, 3, 5, 7 будут представлены блок-схемы описанных ниже алгоритмов, а на рисунках 2, 4, 6, 8
%скриншоты работы программ. При этом на рисунке 9 будет показана диаграмма времени работы каждой программы на разных наборах вводимых данных.


\section{Архитектура NodeJS}
В основе NodeJS лежит выполнение приложения в одном программном потоке, а также асинхронная обработка всех событий. При запуске NodeJS-приложения создается единственный программный поток. NodeJS-приложение выполняется в этом потоке в ожидании, что некое приложение сделает запрос. Когда NodeJS-приложение получает запрос, то никакие другие запросы не обрабатываются до тех пор, пока не завершится обработка текущего запроса.

На первый взгляд, все это кажется не очень эффективным, если бы не то обстоятельство, что NodeJS работает в асинхронном режиме, используя цикл обработки событий и функции обратного вызова. Цикл обработки событий просто опрашивает конкретные события и в нужное время вызывает обработчики событий. В NodeJS таким обработчиком событий является функция обратного вызова.

В отличие от других однопоточных приложений, когда к NodeJS - приложению делается запрос, оно должно, в свою очередь, запросить какие-то ресурсы (например, получить доступ к файлу или обратиться к базе данных). В этом случае NodeJS инициирует запрос но не ожидает ответа на этот запрос. Вместо этого запросу назначается некая функция обратного вызова.Когда запрошенное значение будет готово (или завершено) генерируется событие, активизирующее соответствующую функцию обратного вызова, призванную что-то сделать либо с результатами запрошенного действия, либо с запрошенными ресурсами.

Если несколько человек обращаются к NodeJS-приложению в одно и то же время и приложению нужно обратиться к ресурсам из файла, для каждого запроса NodeJS назначает свою функцию обратного вызова событию ответа. Когда для каждого из них ресурс становится доступен, вызывается нужная функция обратного вызова, и запрос удовлетворяется. В промежутке NodeJS-приложение может обрабатывать другие запросы либо для того же приложения, либо для какого-нибудь другого.

Хотя приложение не обрабатывает запросы в параллельном режиме, в зависимости от своей загруженности и конструкции можно даже не заметить задержки в ответе. А что лучше всего, приложение очень экономно относится к памяти и к другим ограниченным ресурсам.\cite{Knut}

\section{Способы асинхронного обмена данными с сервером}
В современном Web асинхронный обмен данными с сервером является практически его неотъемлемой частью. Подобный обмен данными позволяет без перезагрузки страницы клиентского приложения обмениваться различной информацией с сервером, что в свою очередь позволяет как повысить интерактивность web-приложений, так и дает возможность обмена данными в режиме реального времени с сервером. 

В далее качестве примеров рассмотрим способы обмена данными с использованием websocket, comet, iframe и jsonp.

\subsection{WebSocket}
WebSocket протокол был утвержден в качестве стандарта RFC 6455 в декабре 2011 года. 
Данный тип соединения предоставляет двунаправленное полнодуплексное соединение.
С помощью WebSocket можно создавать интерактивные браузерные веб-приложения, которые постоянно обмениваются данными с сервером, но при этом не нуждаются в открытии нескольких HTTP-соединений.


\subsection{Comet}
Другое название метода --- <<Очередь ожидающих запросов>>. 

Основа работы данного метода состоит из следующей последовательности шагов:
\begin{itemize}
    \item Отправляется запрос на сервер
    \item Соединение не закрывается сервером пока не появится событие;
    \item Событие отправляется в ответ на запрос;
    \item Клиент тут же отправляет новый ожидающий запрос.
\end{itemize}

Ситуация, когда браузер отправляет запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.

При этом если соединение рвётся само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.

\subsection{IFrame}

\subsection{jsonp}




%\begin{enumerate}
% \item Античный алгоритм Евклида (через разности); 
% \item Алгоритм Евклида (через остатки);
% \item Нахождение $\nod$ методом перебора;
% \item Бинарный алгоритм Стейна.
%\end{enumerate}

\subsection{Античный алгоритм Евклида}
Суть алгоритма заключается в том, что если даны два числа, и одно из них равно нулю, то в ответ записывается
большее из них. Если ни одно из них не равно нулю, тогда вычитаем из большего числа меньшее, а потом
снова проверяем условие равенства одного из них нулю. 

\subsection{Алгоритм Евклида} 
В алгоритме Евклида, если одно из чисел равно нулю, то в ответ записывается
наибольшее из них. Иначе большему числу присваиваем остаток от деления его на меньшее, а потом
снова проверяем условие равенства одного из них нулю.
%Однако, если вычитание заменить на остаток от деления, то эффективность алгоритма существенно возрастает.
%Например, даны числа 2 и 1024. Если использовать вычитание, то потребуется сделать 512 шагов. Но при 
%использовании остатка от деления количество шагов уменьшается до 1.

\subsection{Алгоритм нахождения НОД методом перебора}
В данном случае мы выбираем $max(a,b)$ и уменьшаем это число на единицу до тех пор, пока $a$ и $b$ не станут одновременно кратны ему.

\subsection{Бинарный алгоритм Стейна}
В 1961 году израильский физик и программист Джозеф Стейн (Josef Stein) представил совершенно иной алгоритм нахождения наибольшего общего делителя \cite{Stein}, использующий, прежде всего, на бинарную арифметику. Этому новому алгоритму совершенно не нужны команды, совершающие операции деления. Основанный исключительно на операциях вычитания, он проверяет, является ли число четным, и делит пополам четные числа (что соответствует в бинарной арифметике сдвигу вправо). 
Бинарный алгоритм поиска наибольшего общего делителя основан прежде всего на четырех простых фактах относительно положительных целых чисел $a$ и $b$:
\begin{enumerate}
%	\item Если оба числа четны, то \[\nod(2a,2b) = 2\nod(a,b).\]
%	\item Если первое число четно, а второе нечетно, то  \[\nod(2a,2b+1) = \nod(a,2b+1).\]
%	\item Также как и в алгоритме Евклида, \[\nod(a,b) = \nod(a-b,b).\]
	\item Если оба числа нечетные, то $a - b$ - четно и   \[|a - b| < max(a,b).\]
\end{enumerate}


\section{Реализация алгоритмов}
В данном разделе приведены описания следующих алгоритмов:
\begin{enumerate}
 \item Античный алгоритм Евклида (через разности); 
 \item Алгоритм Евклида (через остатки);
% \item Нахождение $\nod$ методом перебора;
 \item Бинарный алгоритм Стейна.
\end{enumerate}
Листинг программ, реализующих эти алгоритмы можно увидеть в приложениях~\ref{listing-nod-1}---\ref{listing-nod-4}.
Стоит заметить, что алгоритмы представленные в этих приложениях были написаны на языке C++ в среде
Visual Studio 2010, и их тестирование на скорость вычисления поставленной задачи проводилось в операционной системе Windows 8, на компьютере
HP Envy m6 1154er с процессором Intel Core i5 3210M,  тактовая частота которого 2.5~ГГц.

\subsection{Подробное описание алгоритмов}
Далее приведены краткие рекомендации по работе с представленными программами, блок-схемы и скриншоты работы программ.

\subsubsection{Античный алгоритм Евклида}
На вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
%Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно. Общий вид реализованного алгоритма представлен на рисунке~\ref{fig:bs-1}. Код программы можно увидеть в приложении~\ref{listing-nod-1}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{antich_evklid.png}
	\caption{\label{fig:bs-1}%
Блок-схема античного алгоритма Евклида}
\end{figure}

На рисунке~\ref{fig:ss-1} можно увидеть скриншот работы программы.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{evkl_prost.png}
	\caption{\label{fig:ss-1}Работа античного алгоритма Евклида}
\end{figure}


%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Пока $a \neq 0$ и $b \neq 0$ переходим к шагу 3;

%Шаг 3) Если $a \geqslant b$, тогда вычитаем из числа $a$ число $b$ и переходим к шагу 2, иначе вычитаем из числа $b$ число $a$ и переходим к шагу 2;

%Шаг 4) Выводим  $a + b$.


\subsubsection{Алгоритм Евклида}
Здесь также, как и в предыдущем описании, на вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
%Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-2}. Общий вид реализованного алгоритма представлен на рисунке~\ref{fig:bs-2}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{evklid.png}
	\caption{\label{fig:bs-2}%
Блок-схема алгоритма Евклида}
\end{figure}

На рисунке~\ref{fig:ss-2} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{evkl_ost.png}
	\caption{\label{fig:ss-2}Работа алгоритма Евклида}
\end{figure}
\newpage
%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Пока $a \neq 0$ и $b \neq 0$ переходим к шагу 3;

%Шаг 3) Если $a \geqslant b$, тогда переменной $a$ присваиваем остаток от деления его на $b$ и переходим к шагу 2, иначе переменной $b$ присваиваем остаток от деления его на $a$ и переходим к шагу 2;

%Шаг 4) Выводим  $a + b$.

\subsubsection{Алгоритм нахождения НОД методом перебора}
Здесь также, как и в двух предыдущих описаниях, на вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
%Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-3}. На рисунке~\ref{fig:bs-3} представлена блок"=схема  реализованного алгоритма.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{perebor.png}
	\caption{\label{fig:bs-3}%
Блок-схема алгоритма для нахождения НОД методом перебора}
\end{figure}

На рисунке~\ref{fig:ss-3} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{perebor_alg.png}
	\caption{\label{fig:ss-3}Работа алгоритма для нахождения НОД методом перебора}
\end{figure}
%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Если $a \geqslant b$, то переменной $gcd$ присваиваем значение переменной $a$, иначе $gcd$ присваиваем значение переменной $b$;

%Шаг 3) Пока $a$ и $b$ одновременно не кратны $gcd$, уменьшаем значение переменной $gcd$ на 1;

%Шаг 4) Выводим  $gcd$.

\subsubsection{Бинарный алгоритм Стейна}
Здесь также, как и в трех предыдущих описаниях, на вход программе должно быть подано два целых положительных числа $a$ и $b$ и нажата клавиша Enter.
%Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-4}. Общий вид реализованного алгоритма представлен в виде блок-схемы на рисунке~\ref{fig:bs-4}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=15cm]{binar.png}
	\caption{\label{fig:bs-4}%
Блок-схема бинарного алгоритма Стейна}
\end{figure}

На рисунке~\ref{fig:ss-4} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{stein.png}
	\caption{\label{fig:ss-4}Работа бинарного алгоритма Стейна
}
\end{figure}

%Теперь рассмотрим работу данного алгоритма на примере $a=5$, $b=125$.
%Поскольку эти значения больше нуля и нечетные, то переходим к условию <<Если  $b > a$>>

%Шаг 1) Если $a = 0$ или $b = 0$, то выводим $a + b$. Иначе переходим к шагу 2;

%Шаг 2) Пока $a$ и $b$ четны делим их на 2 и увеличиваем $deg$ на 1\\ ($deg$ - степень 2);

%Шаг 3) Если $a \neq 0$, то пока $a$ четное делим его на 2. Иначе переходим к шагу 4;

%Шаг 4) Если $b \neq 0$ переходим к шагу 5. Иначе выводим $a$ умноженное на $2^{deg}$;

%Шаг 5) Пока $b$ четно делим его на 2;

%Шаг 6) Если $b > a$, то вычитаем из $b$ значение переменной $a$ и переходим к шагу 7. Иначе 
%переменной $buf$ присваиваем $a  - b$, переменной $a$ присваиваем значение переменной $b$,
%а переменной $b$ присваиваем $buf$ и переходим к шагу 7;

%Шаг 7) Делим $b$ на 2 и переходим к шагу 4.

\subsection{Экспериментальные данные}
Время работы алгоритма Евклида оценивается теоремой Ламе, которая устанавливает поразительную связь с последовательностью Фибоначчи:

Если $a > b \geqslant 1$  и $b < F_n$  для некоторого $n$, то алгоритм Евклида выполнит не более $n - 2$ рекурсивных вызовов.

Более того, можно показать, что верхняя граница этой теоремы --- оптимальная. При $a = F_n$, $b = F_{n - 1}$ будет выполнено именно $n - 2$ рекурсивных вызова. Иными словами, последовательные числа Фибоначчи --- наихудшие входные данные для алгоритма Евклида.

Учитывая, что числа Фибоначчи растут экспоненциально (как константа в степени $n$), получаем, что алгоритм Евклида выполняется за $O(\log \min(a,b))$ операций умножения.

На языке C++ в среде Microsoft Visual Studio рассмотренные алгоритмы были реализованы. Для проведения сравнительного анализа была написана вспомогательная программа, реализующая алгоритм нахождения $n$-го числа Фибоначчи.
Проведенные эксперименты показали, что алгоритм Евклида
является наиболее эффективным из всех рассмотренных.

%\begin{itemize}
%    \item с правилами оформления курсовых и выпускных квалификационных работ, принятых в Саратовском государственном университете в 2012 году;
% \item с правилами оформления титульного листа отчета о прохождении практики в соответствии со стандартом.
%\end{itemize}


%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv} 
\bibliography{my}
\newpage
% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix

\section{Листинг античного алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-1}
Код приложения \verb"obalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{obalg.txt}

\section{Листинг алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-2}
Код приложения \verb"ostalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{ostalg.txt}


\section{Листинг алгоритма для нахождения НОД методом перебора, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-3}
Код приложения \verb"pralg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{pralg.txt}

\newpage

\section{Листинг бинарного алгоритма Стейна, написанного на Microsoft Visual Studio C++ 2010.}\label{listing-nod-4}
Код приложения \verb"binalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{binalg.txt}

\section{Листинг программы для нахождения чисел Фибоначчи, написанного на Delphi 7.0}\label{listing-nod-5}
Код приложения \verb"fib.dpr".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{fib.txt}

%\section{Таблица}
%\begin{table}[!ht]
%	\footnotesize
%	\caption{Results of pass-fail dictionary reduction with the help
%	of masks} \label{table-2}
%	\begin{tabular}{|p{1.5cm}|
	%                 p{1.5cm}|
%	                 p{1.5cm}|
%	               p{1.5cm}|
%	                 p{1cm}|}
%		\hline \centering Circuit & Number of modelled faults & Number of test
%		vectors in the test set & The volume of pass-fail dictionary,
%		\linebreak bit & The volume of found mask
%		\\
%		\hline S298 & 177 & 322 & 56994 & 30 & 5310 & 9,32\% & 0,07\\
%		\hline S344 & 240 & 127 & 30480 & 29 & 6960 & 22,83\% & 0,04\\
%		\hline S349 & 243 & 134 & 32562 & 35 & 8505 & 26,12\% & 0,05\\
%		\hline S382 & 190 & 2074 & 394060 & 28 & 5320 & 1,35\% & 0,43\\
%		\hline S386 & 274 & 286 & 78364 & 65 & 17810 & 22,73\% & 0,26\\
%		\hline S400 & 194 & 2214 & 429516 & 32 & 6208 & 1,45\% & 0,99\\
%		\hline S444 & 191 & 2240 & 427840 & 30 & 5730 & 1,34\% & 0,98\\
%		\hline S526 & 138 & 2258 & 311604 & 28 & 3864 & 1,24\% & 0,61\\
%		\hline S641 & 345 & 209 & 72105 & 58 & 20010 & 27,75\% & 0,24\\
%		\hline S713 & 343 & 173 & 59339 & 58 & 19894 & 33,53\% & 0,19\\
%		\hline S820 & 712 & 1115 & 793880 & 147 & 104664 & 13,18\% & 9,09\\
%		\hline S832 & 719 & 1137 & 817503 & 151 & 108569 & 13,28\% & 9,20\\
%		\hline S953 & 326 & 14 & 4564 & 13 & 4238 & 92,86\% & 0,01\\
%		\hline S1423 & 293 & 150 & 43950 & 58 & 16994 & 38,67\% & 0,15\\
%		\hline S1488 & 1359 & 1170 & 1590030 & 158 & 214722 & 13,50\% & 26,69\\
%		\hline
%	\end{tabular}
%\end{table}
%\newpage
%\centering
%Курсовая работа по теме <<Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного>>   выполнена мною самостоятельно и на все источники даны соответствующие ссылки.

\end{document}
