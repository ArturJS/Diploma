\documentclass[master, och, coursework, times]{SCWorks}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage[colorlinks=false]{hyperref}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\renewcommand{\nod}{\mathop{\text{НОД}}}
\renewcommand{\nok}{\mathop{\text{НОК}}}

\newtheorem{lem}{Лемма}



\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\worktitle{Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного.}

% Курс
\course{1}

% Группа
\group{111}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{010300 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{010500 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{230100 "--- Информатика и вычислительная техника}
%\napravlenie{231000 "--- Программная инженерия}
%\napravlenie{090301 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\studentName{Низамутдинова Артура Салаватовича}

% Заведующий кафедрой
\chtitle{к.ф.-м.н.} % степень, звание
\chname{А.~С.~Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.~ф.-м.~н.} %должность, степень, звание
\saname{С.~В.~Миронов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.ф.-м.н., доцент}
\paname{А.~С.~Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{производственно-технологическая}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{3}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.01.2012}
\practFinish{01.01.2012}

% Год выполнения отчета
\year{2013}

\MakeTitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
\abbreviations
\begin{description}
    \item $\nod$  "--- наибольший общий делитель;
    \item $\nok$  "--- наименьшее общее кратное;
\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
Алгоритмы для нахождения наибольшего общего делителя ($\nod$) и наименьшего общего кратного ($\nok$) в настоящее время являются довольно значимыми.
К примеру $\nod$ применяется в криптографическом алгоритме с
открытым ключом RSA (аббревиатура от фамилий Rivest, Shamir и Adleman), а также имеет частое применение
в математике. В свою очередь с помощью $\nok$ производится приведение дробей к общему знаменателю.

Целью настоящей работы является приведение примеров, а также сравнение эффективности алгоритмов для нахождения $\nod$ и $\nok$ двух натуральных чисел.

Поставленные задачи:
\begin{itemize}
    \item рассмотреть понятия $\nod$ и $\nok$;
    \item рассмотреть алгоритмы для их нахождения;
    \item подробно описать эти алгоритмы;
    \item реализовать алгоритмы в Microsoft Visual Studio C++ 2010;
    \item сравнить эффективность алгоритмов для их нахождения.
\end{itemize}

%Также на рисунках 1, 3, 5, 7 будут представлены блок-схемы описанных ниже алгоритмов, а на рисунках 2, 4, 6, 8
%скриншоты работы программ. При этом на рисунке 9 будет показана диаграмма времени работы каждой программы на разных наборах вводимых данных.


\section{История}

Математики в древней Греции называли алгоритм для нахождения $\nod$ <<взаимное вычитание>>. 
Этот алгоритм был впервые описан в книге Евклида <<Начала>> (около 300 г. до н.э.), хотя некоторые ученые предполагают, что данный метод был известен за 200 лет до этого, по крайней мере в той форме, которая использует вычитания. В <<Началах>> Евклида данный алгоритм описывается два раза --- в седьмой книге для вычисления $\nod$
двух натуральных чисел, а также в десятой книге для вычисления $\nok$ двух чисел. В каждом из этих случаев дано геометрическое описание, для поиска <<общей меры>> двух отрезков. Однако данный алгоритм для нахождения $\nod$ двух натуральных чисел также описан в I книге древнекитайского писания <<Математика в девяти томах>>. 

Алгоритм Евклида можно назвать дедушкой всех алгоритмов, поскольку он самый старый из всех нетривиальных алгоритмов, дошедших до наших дней.\cite{Knut}

\section{Наибольший общий делитель и наименьшее общее кратное}
Наибольший общий делитель целых $a$, $b$ --- это такой их общий делитель, который делится на любой общий делитель этих чисел.

Наименьшее общее кратное целых $a$, $b$ --- это такое наименьшее натуральное число, которое делится на $a$ и $b$.

Если числа $a$ и $b$ представить в виде $a = p_1{}^{d_1} \cdotp \ldots \cdotp p_n{}^{d_n}$
$b = p_1{}^{e_1} \cdotp \ldots \cdotp p_n{}^{e_n}$, где $p_1{}, \ldots , p_n{}$ --- простые числа,
$e_1{}, \ldots , e_n{}$ и $d_1{}, \ldots , d_n{}$ --- целые неотрицательные числа (некоторые из них могут быть равны нулю, если соответствующего простого числа нет в разложении). Тогда $\nod$ и $\nok$ этих чисел можно представить в следующем виде:\\
\[\nod (a,b) = p_1{}^{min(d_1,e_1)} \cdotp \ldots \cdotp p_n{}^{min(d_n,e_n)}\]
\[\nok(a,b) = p_1{}^{max(d_1,e_1)} \cdotp \ldots \cdotp p_n{}^{max(d_n,e_n)}\]

Пусть $a$ и $b$ --- два каких-то целых числа, не равных одновременно нулю; рассмотрим совокупность всех натуральных чисел, на которые делятся и $a$ и $b$. Эта совокупность, несомненно, конечная, так как если, например, $a \neq 0$, то никакое число, большее чем $a$, не может быть делителем $a$. Отсюда следует, что число общих делителей $a$ и $b$ конечно; пусть через $d$ обозначен наибольший из них. Число $d$ называется общим наибольшим делителем $a$ и $b$, и мы условимся обозначать его $d = (a, b)$. Если $a$ и $b$ --- достаточно большие числа, например $a = 24157819$, $b = 39088167$, то попытки найти общий наибольший делитель с помощью непосредственных проб довольно утомительны \cite{Kurant}. Короткий и вполне надежный метод вытекает из алгоритмов нахождения $\nod$. 

\section{Алгоритмы нахождения наибольшего общего делителя}
Для вычисления $\nod$ двух чисел существуют следующие алгоритмы:
\begin{enumerate}
 \item Античный алгоритм Евклида (через разности); 
 \item Алгоритм Евклида (через остатки);
 \item Нахождение $\nod$ методом перебора;
 \item Бинарный алгоритм Стейна.
\end{enumerate}

$\nok$ можно вычислить при помощи следующей формулы 
\[\nok=\frac{a  b}{\nod(a,b)}.\]


\subsection{Античный алгоритм Евклида}
Суть алгоритма заключается в том, что если даны два числа, и одно из них равно нулю, то в ответ записывается
большее из них. Если ни одно из них не равно нулю, тогда вычитаем из большего числа меньшее, а потом
снова проверяем условие равенства одного из них нулю. 

\subsection{Алгоритм Евклида} 
В алгоритме Евклида, если одно из чисел равно нулю, то в ответ записывается
наибольшее из них. Иначе большему числу присваиваем остаток от деления его на меньшее, а потом
снова проверяем условие равенства одного из них нулю.
%Однако, если вычитание заменить на остаток от деления, то эффективность алгоритма существенно возрастает.
%Например, даны числа 2 и 1024. Если использовать вычитание, то потребуется сделать 512 шагов. Но при 
%использовании остатка от деления количество шагов уменьшается до 1.

\subsection{Алгоритм нахождения НОД методом перебора}
В данном случае мы выбираем $max(a,b)$ и уменьшаем это число на единицу до тех пор, пока $a$ и $b$ не станут одновременно кратны ему.

\subsection{Бинарный алгоритм Стейна}
В 1961 году израильский физик и программист Джозеф Стейн (Josef Stein) представил совершенно иной алгоритм нахождения наибольшего общего делителя \cite{Stein}, использующий, прежде всего, на бинарную арифметику. Этому новому алгоритму совершенно не нужны команды, совершающие операции деления. Основанный исключительно на операциях вычитания, он проверяет, является ли число четным, и делит пополам четные числа (что соответствует в бинарной арифметике сдвигу вправо). 
Бинарный алгоритм поиска наибольшего общего делителя основан прежде всего на четырех простых фактах относительно положительных целых чисел $a$ и $b$:
\begin{enumerate}
	\item Если оба числа четны, то \[\nod(2a,2b) = 2\nod(a,b).\]
	\item Если первое число четно, а второе нечетно, то  \[\nod(2a,2b+1) = \nod(a,2b+1).\]
	\item Также как и в алгоритме Евклида, \[\nod(a,b) = \nod(a-b,b).\]
	\item Если оба числа нечетные, то $a - b$ - четно и   \[|a - b| < max(a,b).\]
\end{enumerate}


\section{Реализация алгоритмов}
В данном разделе приведены описания следующих алгоритмов:
\begin{enumerate}
 \item Античный алгоритм Евклида (через разности); 
 \item Алгоритм Евклида (через остатки);
 \item Нахождение $\nod$ методом перебора;
 \item Бинарный алгоритм Стейна.
\end{enumerate}
Листинг программ, реализующих эти алгоритмы можно увидеть в приложениях~\ref{listing-nod-1}---\ref{listing-nod-4}.
Стоит заметить, что алгоритмы представленные в этих приложениях были написаны на языке C++ в среде
Visual Studio 2010, и их тестирование на скорость вычисления поставленной задачи проводилось в операционной системе Windows 8, на компьютере
HP Envy m6 1154er с процессором Intel Core i5 3210M,  тактовая частота которого 2.5~ГГц.

\subsection{Подробное описание алгоритмов}
Далее приведены краткие рекомендации по работе с представленными программами, блок-схемы и скриншоты работы программ.

\subsubsection{Античный алгоритм Евклида}
На вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно. Общий вид реализованного алгоритма представлен на рисунке~\ref{fig:bs-1}. Код программы можно увидеть в приложении~\ref{listing-nod-1}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{antich_evklid.png}
	\caption{\label{fig:bs-1}%
Блок-схема античного алгоритма Евклида}
\end{figure}

На рисунке~\ref{fig:ss-1} можно увидеть скриншот работы программы.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{evkl_prost.png}
	\caption{\label{fig:ss-1}Работа античного алгоритма Евклида}
\end{figure}


%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Пока $a \neq 0$ и $b \neq 0$ переходим к шагу 3;

%Шаг 3) Если $a \geqslant b$, тогда вычитаем из числа $a$ число $b$ и переходим к шагу 2, иначе вычитаем из числа $b$ число $a$ и переходим к шагу 2;

%Шаг 4) Выводим  $a + b$.


\subsubsection{Алгоритм Евклида}
Здесь также, как и в предыдущем описании, на вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-2}. Общий вид реализованного алгоритма представлен на рисунке~\ref{fig:bs-2}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{evklid.png}
	\caption{\label{fig:bs-2}%
Блок-схема алгоритма Евклида}
\end{figure}

На рисунке~\ref{fig:ss-2} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{evkl_ost.png}
	\caption{\label{fig:ss-2}Работа алгоритма Евклида}
\end{figure}
\newpage
%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Пока $a \neq 0$ и $b \neq 0$ переходим к шагу 3;

%Шаг 3) Если $a \geqslant b$, тогда переменной $a$ присваиваем остаток от деления его на $b$ и переходим к шагу 2, иначе переменной $b$ присваиваем остаток от деления его на $a$ и переходим к шагу 2;

%Шаг 4) Выводим  $a + b$.

\subsubsection{Алгоритм нахождения НОД методом перебора}
Здесь также, как и в двух предыдущих описаниях, на вход программе должно быть подано два целых положительных числа (те самые числа $a$ и $b$) и нажата клавиша Enter.
Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-3}. На рисунке~\ref{fig:bs-3} представлена блок"=схема  реализованного алгоритма.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=7cm]{perebor.png}
	\caption{\label{fig:bs-3}%
Блок-схема алгоритма для нахождения НОД методом перебора}
\end{figure}

На рисунке~\ref{fig:ss-3} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{perebor_alg.png}
	\caption{\label{fig:ss-3}Работа алгоритма для нахождения НОД методом перебора}
\end{figure}
%Шаг 1) Ввод $a$ и $b$;

%Шаг 2) Если $a \geqslant b$, то переменной $gcd$ присваиваем значение переменной $a$, иначе $gcd$ присваиваем значение переменной $b$;

%Шаг 3) Пока $a$ и $b$ одновременно не кратны $gcd$, уменьшаем значение переменной $gcd$ на 1;

%Шаг 4) Выводим  $gcd$.

\subsubsection{Бинарный алгоритм Стейна}
Здесь также, как и в трех предыдущих описаниях, на вход программе должно быть подано два целых положительных числа $a$ и $b$ и нажата клавиша Enter.
Далее во второй, третьей и четвертой строке появятся $\nod(a,b)$,  $\nok(a,b)$ и время работы программы в 
миллисекундах соответственно.  Код программы можно увидеть в приложении~\ref{listing-nod-4}. Общий вид реализованного алгоритма представлен в виде блок-схемы на рисунке~\ref{fig:bs-4}.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=15cm]{binar.png}
	\caption{\label{fig:bs-4}%
Блок-схема бинарного алгоритма Стейна}
\end{figure}

На рисунке~\ref{fig:ss-4} можно увидеть скриншот работы программы.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=10cm]{stein.png}
	\caption{\label{fig:ss-4}Работа бинарного алгоритма Стейна
}
\end{figure}

%Теперь рассмотрим работу данного алгоритма на примере $a=5$, $b=125$.
%Поскольку эти значения больше нуля и нечетные, то переходим к условию <<Если  $b > a$>>

%Шаг 1) Если $a = 0$ или $b = 0$, то выводим $a + b$. Иначе переходим к шагу 2;

%Шаг 2) Пока $a$ и $b$ четны делим их на 2 и увеличиваем $deg$ на 1\\ ($deg$ - степень 2);

%Шаг 3) Если $a \neq 0$, то пока $a$ четное делим его на 2. Иначе переходим к шагу 4;

%Шаг 4) Если $b \neq 0$ переходим к шагу 5. Иначе выводим $a$ умноженное на $2^{deg}$;

%Шаг 5) Пока $b$ четно делим его на 2;

%Шаг 6) Если $b > a$, то вычитаем из $b$ значение переменной $a$ и переходим к шагу 7. Иначе 
%переменной $buf$ присваиваем $a  - b$, переменной $a$ присваиваем значение переменной $b$,
%а переменной $b$ присваиваем $buf$ и переходим к шагу 7;

%Шаг 7) Делим $b$ на 2 и переходим к шагу 4.



%\begin{itemize}
%    \item с правилами оформления курсовых и выпускных квалификационных работ, принятых в Саратовском государственном университете в 2012 году;
% \item с правилами оформления титульного листа отчета о прохождении практики в соответствии со стандартом.
%\end{itemize}


%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv} 
\bibliography{my}
\newpage
% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix

\section{Листинг античного алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-1}
Код приложения \verb"obalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{obalg.txt}

\section{Листинг алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-2}
Код приложения \verb"ostalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{ostalg.txt}


\section{Листинг алгоритма для нахождения НОД методом перебора, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-3}
Код приложения \verb"pralg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{pralg.txt}

\newpage

\section{Листинг бинарного алгоритма Стейна, написанного на Microsoft Visual Studio C++ 2010.}\label{listing-nod-4}
Код приложения \verb"binalg.cpp".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{binalg.txt}

\section{Листинг программы для нахождения чисел Фибоначчи, написанного на Delphi 7.0}\label{listing-nod-5}
Код приложения \verb"fib.dpr".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{fib.txt}

%\section{Таблица}
%\begin{table}[!ht]
%	\footnotesize
%	\caption{Results of pass-fail dictionary reduction with the help
%	of masks} \label{table-2}
%	\begin{tabular}{|p{1.5cm}|
	%                 p{1.5cm}|
%	                 p{1.5cm}|
%	               p{1.5cm}|
%	                 p{1cm}|}
%		\hline \centering Circuit & Number of modelled faults & Number of test
%		vectors in the test set & The volume of pass-fail dictionary,
%		\linebreak bit & The volume of found mask
%		\\
%		\hline S298 & 177 & 322 & 56994 & 30 & 5310 & 9,32\% & 0,07\\
%		\hline S344 & 240 & 127 & 30480 & 29 & 6960 & 22,83\% & 0,04\\
%		\hline S349 & 243 & 134 & 32562 & 35 & 8505 & 26,12\% & 0,05\\
%		\hline S382 & 190 & 2074 & 394060 & 28 & 5320 & 1,35\% & 0,43\\
%		\hline S386 & 274 & 286 & 78364 & 65 & 17810 & 22,73\% & 0,26\\
%		\hline S400 & 194 & 2214 & 429516 & 32 & 6208 & 1,45\% & 0,99\\
%		\hline S444 & 191 & 2240 & 427840 & 30 & 5730 & 1,34\% & 0,98\\
%		\hline S526 & 138 & 2258 & 311604 & 28 & 3864 & 1,24\% & 0,61\\
%		\hline S641 & 345 & 209 & 72105 & 58 & 20010 & 27,75\% & 0,24\\
%		\hline S713 & 343 & 173 & 59339 & 58 & 19894 & 33,53\% & 0,19\\
%		\hline S820 & 712 & 1115 & 793880 & 147 & 104664 & 13,18\% & 9,09\\
%		\hline S832 & 719 & 1137 & 817503 & 151 & 108569 & 13,28\% & 9,20\\
%		\hline S953 & 326 & 14 & 4564 & 13 & 4238 & 92,86\% & 0,01\\
%		\hline S1423 & 293 & 150 & 43950 & 58 & 16994 & 38,67\% & 0,15\\
%		\hline S1488 & 1359 & 1170 & 1590030 & 158 & 214722 & 13,50\% & 26,69\\
%		\hline
%	\end{tabular}
%\end{table}
%\newpage
%\centering
%Курсовая работа по теме <<Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного>>   выполнена мною самостоятельно и на все источники даны соответствующие ссылки.

\end{document}
