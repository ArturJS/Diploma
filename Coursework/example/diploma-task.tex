\documentclass[bachelor, och, assignment, times]{SCWorks} 
% параметр - тип обучения - одно из значений: 
% spec - специальность 
% bachelor - бакалавриат (по умолчанию) 
% master - магистратура 
% параметр - форма обучения - одно из значений: 
% och - очное (по умолчанию) 
% zaoch - заочное 
% параметр - тип работы - одно из значений: 
% referat - реферат 
% coursework - курсовая работа (по умолчанию) 
% diploma - дипломная работа 
% pract - отчет по практике 
% параметр - включение шрифта 
% times - включение шрифта Times New Roman (если установлен) 
% по умолчанию выключен 
\usepackage[T2A]{fontenc} 
\usepackage[cp1251]{inputenc} 
\usepackage{graphicx} 

\usepackage[sort,compress]{cite} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{fancyvrb} 
\usepackage{longtable} 
\usepackage{array} 
\usepackage[english,russian]{babel} 
\usepackage{tikz} 


\usepackage[colorlinks=false]{hyperref} 

\newcommand{\eqdef}{\stackrel {\rm def}{=}} 

\newtheorem{lem}{Лемма} 

\begin{document} 

% Кафедра (в родительном падеже) 
\chair{математической кибернетики и компьютерных наук} 

% Тема работы 
%\title{Разработка приложения на языке C++ в среде Microsoft VisualStudio} 
\title{Разработка высоконагруженных приложений на языке JavaScript.} 

% Курс 
\course{4} 

% Группа 
\group{411} 

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ") 
%\department{факультета КНиИТ} 

% Специальность/направление код - наименование 
\napravlenie{02.03.02 "-— Фундаментальная информатика и информационные технологии} 
%\napravlenie{010500 "-— Математическое обеспечение и администрирование информационных систем} 
%\napravlenie{230100 "-— Информатика и вычислительная техника} 
%\napravlenie{231000 "-— Программная инженерия} 
%\napravlenie{090301 "-— Компьютерная безопасность} 

% Для студентки. Для работы студента следующая команда не нужна. 
\studenttitle{Студента} 

% Фамилия, имя, отчество в родительном падеже 
\author{Низамутдинова Артура Салаватовича} 

% Заведующий кафедрой 
\chtitle{к.ф.-м.н.} % степень, звание 
\chname{С.~В.~Миронов} 

%Научный руководитель (для реферата преподаватель проверяющий работу) 
\satitle{доцент} %должность, степень, звание 
\saname{И.~А.~Борзов} 

% Руководитель практики от организации (только для практики, 
% для остальных типов работ не используется) 
\patitle{доцент} 
\paname{И.~А.~Борзов} 

% Семестр (только для практики, для остальных 
% типов работ не используется) 
\term{8} 

% Наименование практики (только для практики, для остальных 
% типов работ не используется) 
\practtype{преддипломная} 

% Продолжительность практики (количество недель) (только для практики, 
% для остальных типов работ не используется) 
\duration{4} 

% Даты начала и окончания практики (только для практики, для остальных 
% типов работ не используется) 
\practStart{06.05.2016} 
\practFinish{02.06.2016} 

% Год выполнения отчета 
\date{2016} 

\maketitle 

% Включение нумерации рисунков, формул и таблиц по разделам 
% (по умолчанию - нумерация сквозная) 
% (допускается оба вида нумерации) 
%\secNumbering 


\tableofcontents 

% Раздел "Обозначения и сокращения". Может отсутствовать в работе 
%\abbreviations 

% Раздел "Определения". Может отсутствовать в работе 
%\definitions 

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе. 
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения" 
%\defabbr

% Раздел "Введение"
\intro
Javascript является высокоуровневым прототипно-ориентированным языком программирования.
Изначально созданный в 1995 году как язык для работы в среде браузера, уже в 1996 году в компании Netscape начали проводиться попытки по адаптированию данного языка под нужды серверной стороны, однако данная технология не получила широкого распространения.

В 2009 году после нескольких лет экспериментирования над созданием серверых веб-компонентов на Javascript Райан Дал  разработал NodeJS.
NodeJS представляет собой платформу, основанную на JavaScript движке V8 (разработанной компанией Google), транслирующем JavaScript в машинный код, таким образом преобразующим JavaScript из узкоспециализированного в
язык общего назначения.
 NodeJS используется преимущественно на сервере,
выполняя роль веб-сервера, но кроме этого есть возможность разрабатывать
на NodeJS и десктопные приложения (с использованием NW.js, Electron или
AppJS для Windows, Linux и Mac OS) и даже программировать микрокон-
троллеры (например, espruino и tessel). Также важно отметить, что NodeJS
используют в своих проектах такие крупные компании как Google, Yahoo,
PayPal, Yammer и многие другие.



%Целью настоящей работы является приведение примеров, а также сравнение эффективности алгоритмов для нахождения $\nod$ и $\nok$ двух натуральных чисел.

Поставленные задачи:
\begin{itemize}
    \item изучить архитектуру NodeJS и NGINX;
    \item рассмотреть способы асинхронного обмена данными с сервером с использованием websocket, comet, iframe и jsonp;
    \item реализовать веб-сервер на websocket и comet;
    \item настроить NGINX как прокси-сервер и балансировщик нагрузки;
    \item провести нагрузочное тестирование comet и websocket соединений и сделать выводы.
\end{itemize}

%Также на рисунках 1, 3, 5, 7 будут представлены блок-схемы описанных ниже алгоритмов, а на рисунках 2, 4, 6, 8
%скриншоты работы программ. При этом на рисунке 9 будет показана диаграмма времени работы каждой программы на разных наборах вводимых данных.


\section{Краткое описание архитектуры NodeJS}
В основе NodeJS лежит выполнение приложения в одном программном потоке, а также асинхронная обработка всех событий. При запуске NodeJS-приложения создается единственный программный поток. NodeJS-приложение выполняется в этом потоке в ожидании, что некое приложение сделает запрос. Когда NodeJS-приложение получает запрос, то никакие другие запросы не обрабатываются до тех пор, пока не завершится обработка текущего запроса.

На первый взгляд, все это кажется не очень эффективным, если бы не то обстоятельство, что NodeJS работает в асинхронном режиме, используя цикл обработки событий и функции обратного вызова. Цикл обработки событий просто опрашивает конкретные события и в нужное время вызывает обработчики событий. В NodeJS таким обработчиком событий является функция обратного вызова.

В отличие от других однопоточных приложений, когда к NodeJS - приложению делается запрос, оно должно, в свою очередь, запросить какие-то ресурсы (например, получить доступ к файлу или обратиться к базе данных). В этом случае NodeJS инициирует запрос но не ожидает ответа на этот запрос. Вместо этого запросу назначается некая функция обратного вызова. Когда запрошенное значение будет готово (или завершено) генерируется событие, активизирующее соответствующую функцию обратного вызова, призванную что-то сделать либо с результатами запрошенного действия, либо с запрошенными ресурсами.

Если несколько человек обращаются к NodeJS-приложению в одно и то же время и приложению нужно обратиться к ресурсам из файла, для каждого запроса NodeJS назначает свою функцию обратного вызова событию ответа. Когда для каждого из них ресурс становится доступен, вызывается нужная функция обратного вызова, и запрос удовлетворяется. В промежутке NodeJS-приложение может обрабатывать другие запросы либо для того же приложения, либо для какого-нибудь другого.

Хотя приложение не обрабатывает запросы в параллельном режиме, в зависимости от своей загруженности и конструкции можно даже не заметить задержки в ответе. А что лучше всего, приложение очень экономно относится к памяти и к другим ограниченным ресурсам.\cite{nodejs}

\section{Краткое описание архитектуры NGINX}

NGINX (сокращение от engine x) --- это HTTP-сервер и обратный прокси-сервер, почтовый, а также TCP/UDP прокси-сервер общего назначения, изначально написанный Игорем Сысоевым. 

Для лучшего представления устройства, сперва необходимо понять как NGINX запускается. У NGINX есть один мастер-процесс (который от имени суперпользователя выполняет такие операции, как открытие портов и чтение конфигурации), а также некоторое количество рабочих и вспомогательных процессов. Например, на 4-х ядерном сервере мастер-процесс NGINX создает 4 рабочих процесса и пару вспомогательных кэш-процессов, которые в свою очередь управляют содержимым кэша на жестком диске.

Говоря о многопоточности важно отметить, что любой процесс или поток --- это набор самодостаточных инструкций, который операционная система может запланировать для выполнения на ядре процессора. Большинство сложных приложений параллельно запускают множество процессов или потоков по двум причинам:
\begin{enumerate}
\item Чтобы одновременно задействовать больше вычислительных ядер;
\item Процессы и потоки позволяют проще выполнять параллельные операции (например работать с множеством соединений одновременно).
\end{enumerate}

\subsection{Несколько слов о важности архитектуры}

Процессы и потоки сами по себе расходуют дополнительные ресурсы. Каждый из процессов или потоков потребляет некоторое количество памяти, и кроме того постоянно подменяют друг друга на процессоре (так называемое переключение контекста). Современные серверы могут справляться с сотнями активных процессов и потоков, но производительность сильно падает, как только заканчивается память или огромное количество операций ввода-вывода приводит к слишком частой смене контекста.

Наиболее типичный подход к построению сетевого приложения --- это выделять для каждого соединения отдельный процесс или поток. Такая архитектура действительно проста для понимания и легка в реализации, но при этом плохо масштабируется, когда приложению приходится работать с тысячами соединений одновременно.\cite{Nginx}

\subsection{Основные моменты работы NGINX}

В NGINX используется архитектура с предварительно заданным числом процессов, которая эффективней всего использует имеющиеся системные ресурсы:

\begin{itemize}
\item Мастер-процесс запускает команды, требующие повышенных прав доступа, такие как открытие портов и чтение конфигурации, после чего порождает несколько дочерних процессов (следующих трех типов).
\item Загрузчик кэша начинает свою работу на старте, для того чтобы загрузить данные кэша, находящиеся на диске, в оперативную память, и затем завершается. Его работа рассчитана таким образом, чтобы потреблять как можно меньше ресурсов.
\item Кэш-менеджер периодически активируется, чтобы удалить данные кэша с жесткого диска, таким образом, поддерживая его объем в заранее заданных границах.
\item Рабочие процессы выполняют основную часть работы. Они работают с сетевыми соединениями, читая и записывая данные на диск, обмениваются данными с бэкенд-серверами.\cite{Nginx}
\end{itemize}

\subsection{Внутри рабочего процесса}

Каждый рабочий процесс NGINX инициализируется с заданной конфигурацией и набором слушающих сокетов, унаследованных от мастер-процесса.

Рабочие процессы начинают с ожидания событий на слушающих сокетах. События извещают о новых соединениях. Эти соединения попадают в конечный автомат --- наиболее часто используемый предназначен для обработки HTTP, но NGINX также содержит конечные автоматы для обработки потоков TCP трафика (модуль stream) и целого ряда протоколов электронной почты (SMTP, IMAP и POP3).

Конечный автомат в NGINX по своей сути является набором инструкций для обработки запроса. Большинство веб-серверов выполняют такую же функцию, но разница кроется в реализации.\cite{Nginx}

\subsection{Устройство конечного автомата}
Конечный автомат можно представить себе в виде правил для игры в шахматы. Каждая HTTP транзакция — это шахматная партия. С одной стороны шахматной доски веб-сервер — гроссмейстер, который принимает решения очень быстро. На другой стороне — удаленный клиент, браузер, который запрашивает сайт или приложение по относительно медленной сети.

Как бы то ни было, правила игры могут быть очень сложными. Например, веб-серверу может потребоваться взаимодействовать с другими ресурсами (проксировать запросы на бэкенд) или обращаться к серверу аутентификации. Сторонние модули способны ещё сильнее усложнить обработку.\cite{Nginx}

\subsection{Блокирующийся конечный автомат}

Вспомните наше определение процесса или потока, как самодостаточного набора инструкций, выполнение которых операционная система может назначать на конкретное ядро процессора. Большинство веб-серверов и веб-приложений используют модель, в которой для «игры в шахматы» приходится по одному процессу или потоку на соединение. Каждый процесс или поток содержит инструкции, чтобы сыграть одну партию до конца. Все это время процесс, выполняясь на сервере, проводит большую часть времени заблокированным в ожидании следующего хода от клиента.

\begin{enumerate}
\item Процесс веб-сервера ожидает новых соединений (новых партий инициированных клиентами) на слушающих сокетах.
\item Получив новое соединение, он играет партию, блокируясь после каждого хода в ожидании ответа от клиента.
\item Когда партия сыграна, процесс веб-сервера может находиться в ожидании желания клиента начать следующую партию (это соответствует долгоживущим keepalive-соединениям). Если соединение закрыто (клиент ушел или наступил таймаут), процесс возвращается к встрече новых клиентов на слушающих сокетах.
\end{enumerate}

Важный момент, который стоит отметить, заключается в том, что каждое активное HTTP-соединение (каждая партия) требует отдельного процесса или потока (гроссмейстера). Такая архитектура проста и легко расширяема с помощью сторонних модулей (новых «правил»). Однако, в ней существует огромный дисбаланс: достаточно легкое HTTP-соединение, представленное в виде файлового дескриптора и небольшого объема памяти, соотносится с отдельным процессом или потоком, достаточно тяжелым объектом в операционной системе. Это удобно для программирования, но весьма расточительно.\cite{Nginx}

\section{Способы асинхронного обмена данными с сервером}
В современном Web асинхронный обмен данными с сервером является практически его неотъемлемой частью. Подобный обмен данными позволяет без перезагрузки страницы клиентского приложения обмениваться различной информацией с сервером, что в свою очередь позволяет как повысить интерактивность web-приложений, так и дает возможность обмена данными в режиме реального времени с сервером. 

В далее качестве примеров рассмотрим способы обмена данными с использованием websocket, comet, iframe и jsonp.

\subsection{WebSocket}
WebSocket протокол был утвержден в качестве стандарта RFC 6455 в декабре 2011 года. 
Данный тип соединения предоставляет двунаправленное полнодуплексное соединение.
С помощью WebSocket можно создавать интерактивные браузерные веб-приложения, которые постоянно обмениваются данными с сервером, но при этом не нуждаются в открытии нескольких HTTP-соединений.

Хоть и WebSocket использует HTTP как основной механизм для передачи данных, однако канал связи не закрывается после получения данных клиентом. Используя WebSocket API вы полностью свободны от ограничений типичного цикла HTTP (request/responce). Это также означает, что до тех пор пока соединение остается открытым, клиент и сервер могут свободно отправлять данные в асинхронном режиме без опроса для чего-нибудь нового.\cite{ws}

Цикл работы WebSocket соединения состоит из следующих этапов:

\begin{itemize}
    \item установления соединения (opening handshake);
    \item оформления и отправки данных;
    \item закрытие соединения (closing handshake).
\end{itemize}

\subsubsection{Установление WebSocket соединения}
Поскольку протокол WebSocket работает поверх HTTP, то это означает, что при подключении браузер отправляет следующие специальные заголовки:

\begin{verbatim}
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
\end{verbatim}


 Описание заголовков:
 
 
       \verb!GET, Host! --- стандартные HTTP---заголовки из URL запроса.

        \verb!Upgrade, Connection! --- указывают, что браузер хочет перейти на websocket.
     
        \verb!Origin! --- протокол, домен и порт, откуда отправлен запрос.

        \verb!Sec-WebSocket-Key! --- случайный ключ, который генерируется браузером: 16 байт в кодировке Base64.

        \verb!Sec-WebSocket-Version! --- версия протокола. Текущая версия: 13.
        
        Все заголовки, кроме \verb!GET! и \verb!Host!, браузер генерирует сам, без возможности вмешательства JavaScript.
        
        
Далее сервер, проанализировав эти заголовки, решает, разрешает ли он соединение WebSocket с данного домена \verb!Origin!.

 В случае, если сервер разрешает WebSocket подключение, то он возвращает клиенту ответ следующего вида:
 \begin{verbatim}
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
 \end{verbatim}
 

Здесь заголовок \verb!Sec-WebSocket-Accept! представляет собой перекодированный с использование специального алгоритма ключ \verb!Sec-WebSocket-Key!. Браузер в свою очередь использует ее для проверки, что ответ предназначается именно ему.

Затем данные передаются по специальному протоколу, структура которого (<<фреймы>>) изложена далее. И это уже совсем не HTTP.\cite{ws}

\subsubsection{Оформление и передача данных с использованием WebSocket протокола}

В протоколе WebSocket предусмотрены несколько видов пакетов (<<фреймов>>).

Они делятся на два больших типа: фреймы с данными (<<data frames>>) и управляющие (<<control frames>>), предназначенные для проверки связи (PING) и закрытия соединения.

На рисунке~\ref{fig:wsframe} можно увидеть общий вид WebSocket фрейма, согласно его стандарту.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{WebSocket-frame.png}
    \caption{\label{fig:wsframe}Схема WebSocket фрейма}
    \end{figure}

\subsubsection{Закрытие WebSocket соединения}
Процесс закрытия WebSocket соединения гораздо проще, чем процесс открытия.

Любая из сторон WebSocket соединения может отправить управляющий фрейм с данными содержащими специальную управляющую последовательность для начала процесса закрытия. После отправки управляющего фрейма, указывающего, что соединение должно быть закрыто, другая сторона в дальнейшем отбрасывает любые данные, которые были отправлены.
В добавок ко всему выше сказанному, процесс закрытия WebSocket соединения безопасен для одновременной инициализации обеими сторонами.\cite{ws2}



\subsection{Comet}
Другое название метода --- <<Очередь ожидающих запросов>>. 

Основа работы данного метода состоит из следующей последовательности шагов:
\begin{itemize}
    \item Отправляется запрос на сервер
    \item Соединение не закрывается сервером пока не появится событие;
    \item Событие отправляется в ответ на запрос;
    \item Клиент тут же отправляет новый ожидающий запрос.
\end{itemize}

Ситуация, когда браузер отправляет запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.

При этом в случае, когда соединение рвется само, к примеру, из-за ошибки в сети, то браузер тут же отсылает новый запрос.\cite{comet}

\subsection{IFrame}

По сути IFrame представляет собой окно браузера, вложенное в основное окно.  

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается невидимый IFrame на специальный URL;
    \item При наступлении событий на сервере в IFrame тут же поступает тег \verb!<script>! --- пакет с данными вида:
    \begin{verbatim}
<script>
parent.handleMessage({txt:"Hello",time:123456789})
</script>
     \end{verbatim} 
    \item Соединение закрывается в случаях:
    \begin{itemize}
        \item при возникновении ошибки;
        \item каждые 20---30 секунд;
        \item когда требуется очистка памяти от старых сообщений (время от времени создаем новый IFrame и удаляем старый).
    \end{itemize}
\end{enumerate}

На рисунке~\ref{fig:iframe} можно увидеть схему работы IFrame транспорта.\cite{iframe}


    \begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{iframe.png}
    \caption{\label{fig:iframe}Общая схема работы IFrame транспорта}
    \end{figure}

\subsection{JSONP}

Если попробовать создать тег \verb!<script src>!, то при добавлении его в документ запустится процесс загрузки с данного \verb!src!. В ответ на запрос сервер может прислать скрипт, который будет содержать нужные данные.

С помощью данного способа можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.

Протокол JSONP --- это своего рода надстройка над таким способом коммуникации.

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается тег \verb!<script>! на специальный URL, в котором в качестве параметра передается имя функции обратного вызова, которая будет вызываться при получении данных;
    \item В свою очередь сервер формирует ответ в виде вызова этой функции с данными переданными в ней в качестве параметров, и отправляет ответ клиенту;
    \item Сразу после того как клиентская сторона получает ответ от сервера, полученный скрипт начинает немедленно выполняться, таким образом вызывая функцию обратного вызова, которая располагается на стороне клиента.
\end{enumerate}

При использовании данного метода необходимо помнить про аспект безопасности, поскольку клиентский код должен доверять серверу при таком способе запроса данных. Ведь серверу ничего не стоит добавить в скрипт любые вредоносные команды.

COMET через протокол JSONP реализуется с использованием длинных запросов, то есть, создается тег \verb!<script>!, браузер запрашивает скрипт у сервера и сервер оставляет соединение висеть, пока не появятся данные, которые необходимо передать клиенту. Когда сервер хочет отправить сообщение --- он формирует ответ с использованием формата JSONP, и тут же клиент отправляет новый запрос.\cite{jsonp}

\section{Описание архитектуры приложения}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{Architecture.png}
    \caption{\label{fig:cluster}Архитектура приложения}
\end{figure}
Архитектура приложения состоит из следующих компонентов:
\begin{itemize}
\item NGINX (прокси-сервер и балансировщик нагрузки)
\item 2 WebSocket сервера
\item 2 Comet сервера
\item Static сервер
\item Messaging сервис
\item Gulp task runner предназначенный для запуска приложения
\end{itemize}

На рисунке~\ref{fig:cluster} можно увидеть общую схему приложения.

Итак, рассмотрим последовательно работу каждого компонента системы:

\begin{enumerate}
\item NGINX 

Данный компонент используется в качестве прокси-сервера и балансировщика нагрузки.
Важной частью NGINX является конфигурационный файл nginx.conf, позволяющий настроить поведение данного компонента.
Инструкции
\begin{verbatim}
upstream websocket {
    least_conn;
    server localhost:8081;
    server localhost:8082;
}

upstream comet {
    ip_hash;
    server 127.0.0.1:8091;
    server 127.0.0.1:8092;
}
\end{verbatim}

описывают две группы серверов: группа из двух websocket серверов и двух comet серверов соответственно. Для websocket группы используется директива балансировки нагрузки \verb|least_conn|, которая передает новое соединение серверу с наименьшим числом активных подключений. В случае comet группы используется директива балансировки \verb|ip_hash|, которая основывается на значении вычисленного хеша ip адреса пользователя, чтобы гарантировать, что все запросы от одного и того же клиента всегда перенаправлялись на один и тот же сервер. Для comet серверов это очень важно, поскольку в случае переподписки пользователя на разные сервера будет происходить постоянное удаление подписчиков на одном сервере и добавление их на другой, что в свою очередь будет пагубно сказываться на производительности приложения в целом. 

Содержимое конфигурационного файла представлено в приложении ~\ref{listing-nod-6}. 

\item WebSocket сервер

На этапе инициализации вызывается функция \verb|init()|, в которой websocket сервер получает номер порта, на котором он будет развернут. После этого вызывается функция \verb|initServer(port)|, в которой создается экземпляр websocket сервера, посредством следующей команды
\begin{verbatim}
var webSocketServer = new WebSocketServer.Server({
    port: port
});
\end{verbatim}
после которой он начинает прослушивать установленный порт. Далее происходит подписка на событие подключения сервера.
\begin{verbatim}
webSocketServer.on('connection', function (ws) {
//здесь код функции обратного вызова, обрабатывающий
//каждое новое подключение
}
\end{verbatim}

В коде выше указанной функции обратного вызова, в момент нового подключения генерируется уникальный идентификатор данного подключения, экземпляр подключения записывается в объект \verb|clients|, а также происходит подписка на событие получения нового сообщения, а также на закрытие этого подключения.

\begin{verbatim}
//краткое содержание вышеописанной функции обратного вызова
//генерируем уникальный идентификатор
var id = _.uniqueId('ws_'); 
clients[id] = ws; // сохраняем экземпляр нового подключения
//в хранилище объекта clients

//подписка на событие получения нового сообщения
ws.on('message', function (message) {
//в случае получения сообщения с неуказанным идентификатором
//происходит отправка идентификатора клиенту
//в противном случае происходит переотправка сообщения
//всем подписчикам данного сервера,
//а также отправка его в messaging сервис
// с помощью метода sendOutWS(message);
}

//подписка на событие закрытия соединения
ws.on('close', function () {
//удаляем подключение из хранилища подписчиков
delete clients[id];
//а также идет отправка сообщения для всех подписчиков
//об уходе данного клиента
sendOutWS({
    type: 'removeClient',
    removeClientId: wsMapIds[id]
});
}
\end{verbatim}
Программный код websocket сервера представлен в приложении ~\ref{listing-nod-2}.

\item Comet сервер

Аналогично websocket серверу, на этапе инициализации также вызывается функция \verb|init()|, в которой comet сервер получает номер порта, на котором он будет развернут. 

\begin{verbatim}
\\парсим номер порта из строки в число
serverPort = port = parseInt(port, 10);
\\инициализируем http сервер
\\прослушивающий заданный порт
\\и вызывающий функцию обратного вызова accept
\\в случае получения каких-либо запросов от клиентов
http.createServer(accept).listen(port);
\end{verbatim}

Далее, если пользователь обратился по пути \verb|/subscribe|, то вызывается функция \verb|onSubscribe(req, res, query);|, в которой происходит сохранение новых подключений в объекте-хранилище \verb|subscribers|, а также подписка на событие закрытия соединения \verb|close|.

\begin{verbatim}
req.on('close', function () {
    //удаляем подключение из объекта-хранилища
    delete subscribers[id];

    //сообщаем всем подписчикам, 
    //что пользователь отсоединился
    sendOutCOMET({
        type: 'removeClient',
        removeClientId: xhrMapIds[id]
    });
});
\end{verbatim}

В случае обращения пользователя по пути \verb|/publish| происходит отправка сообщения всем подписчикам с помощью метода \verb|publish|, который в свою очередь вызывает метод \verb|sendOutCOMET(message)|, который уже делает переотправку сообщения подписчикам текущего сервера, а также передает сообщение messaging сервису.
Программный код comet сервера представлен в приложении ~\ref{listing-nod-1}.

\item Static сервер

Данный сервер используется для возврата UI (от user interface - пользовательский интерфейс) функционала (html + css + javascript), то есть все то, что необходимо клиенту для дальнейшей работы с приложением.

\begin{verbatim}
var express = require('express'),//подключаем модуль express
    app = express(),//получаем объект static сервера
    __dirname = './public';//относительный путь к директории

//устанавливаем путь к директории,
//содержимое которой необходимо возвращать клиенту
app.use(express.static(__dirname));
app.listen(8088);//задаем порт, который нужно прослушивать
\end{verbatim}
Программный код static сервера представлен в приложении ~\ref{listing-nod-3}.

\item Messaging сервис

Данный сервис специализируется на выдаче портов для comet и websocket серверов, а также пересылает сообщения между экземплярами серверов. Для переотправки сообщений используется собственный websocket сервер, на который на старте инициализации подписываются основные comet и websocket сервера.

\begin{verbatim}
webSocketServer = new ws.Server({
    port: 4010
});//создается новый экземпляр websocket сервера

//происходит подписка на событие подключения 
//экземпляров основных comet и websocket серверов.
webSocketServer.on('connection', function (ws) {
    var id = urlToProcessId(ws.upgradeReq.url);

    //сохраняем подключение 
    subscribers[id] = ws;

   //подписываемся на получение нового сообщения
    ws.on('message', function (message) {
        var key;

        //переотправляем сообщение для
        //остальных серверов
        for (key in subscribers) {
            if (subscribers.hasOwnProperty(key) 
            	&& key !== id) {
                subscribers[key].send(message);
            }
        }
    });

    ws.on('close', function () {
       //удаляем соединение из объекта-хранилища
       //в случае его закрытия
        delete subscribers[id];
    });
});
\end{verbatim}

Программный код messaging сервиса представлен в приложении ~\ref{listing-nod-3}.

\item Gulp task runner
 
Предназначен для запуска приложения и нагрузочных тестов.
В случае запуска приложения, необходимо открыть консоль в директории с \verb|gulpfile.js| и прописать команду \verb|gulp serve|. Эта команда вызывает данный фрагмент кода.

\begin{verbatim}
gulp.task('serve', function () {
    var serverHelper;
    stopNginx = true;//флаг для остановки NGINX после 
							//закрытия консоли
							
	//запускаем .bat файл с инструкциями для перезапуска  
	//NGINX сервера					
    exec('start restart-nginx.bat', callback);
    
    //создаем дочерний процесс, 
    //в котором будет работать messaging сервис
    serverHelper = fork('server-helper-util.js', 
    {maxBuffer: maxBufferSize}, callback);

    serverHelper.on('message', function (msg) {
    //когда messaging сервис инициализировался
        if (msg === 'done') {
        //запускаем в дочерних процессах
        //2 websocket сервера
        //2 comet сервера
        //и 1 static сервер
            fork('static-server.js', 
            {maxBuffer: maxBufferSize}, callback);
            
            fork('ws-server.js', 
            {maxBuffer: maxBufferSize}, callback);
            fork('ws-server.js', 
            {maxBuffer: maxBufferSize}, callback);
            
            fork('comet-server.js', 
            {maxBuffer: maxBufferSize}, callback);
            fork('comet-server.js', 
            {maxBuffer: maxBufferSize}, callback);
        }
    });
});
\end{verbatim}

Программный код gulp task runner представлен в приложении ~\ref{listing-nod-5}.
\end{enumerate}

\subsection{Цикл работы приложения}
Итак, подведем краткие итоги вышесказанному.

Рабочий процесс приложения происходит в рамках следующих простых этапов:
\begin{enumerate}
\item После развертывания приложения, пользователи, в первый раз обращающиеся к нему, получают основной функционал для полноценной работы с приложением (html + css + javascript)
\item Получив интерфейс для работы с приложением, пользователю предоставляется возможность выбрать протокол, через который будет проходить обмен данными с сервером (в данном случае пользователь отправляет координаты своего местоположения с определенным интервалом).
\item В ситуации, если пользователь выбрал WebSocket соединение, то NGINX, используя директиву \verb!least_conn!, перенаправляет запрос на активацию соединения к тому WebSocket серверу, который в текущий момент имеет наименьшее число подключений.
\item Однако, если пользователь выбрал Comet соединение, то в этом случае NGINX, используя директиву \verb!ip_hash!, создает специальный хеш для ip адреса пользователя, чтобы все последующие запросы шли на изначально определенный Comet сервер.
\item В дальнейшем сообщение переотправляется всем подписчикам данного экземпляра сервера, а также передается в Messaging сервис, который в свою очередь пересылает сообщение другим экземплярам серверов кластера. Далее эти экземпляры пересылают это сообщение для своих подписчиков.
\end{enumerate}


\section{Нагрузочное тестирование Comet и WebSocket соединений}
Для тестирования Comet и WebSocket соединений также были созданы 2 программы, которые можно запустить, открыв \verb!gulp-test-comet.bat! или \verb!gulp-test-ws.bat! для тестирования соответствующего типа соединения. Перед тестированием не забудьте открыть \verb!gulp-serve.bat! для запуска приложения. Данные \verb!.bat! файлы содержат команды \verb!gulp test-comet --i 100! и \verb!gulp test-ws --i 100!, запускающие 100 NodeJS процессов, которые в свою очередь подключаются к приложению и начинают получать сообщения от процесса-отправителя (\verb!test-comet-send.js! и \verb!test-ws-send.js! для comet и websocket соединения соответственно). Процесс-отправитель отправляет сообщения длиной 16 символов в кодировке $UTF-8$ с интервалом в несколько миллисекунд.
На рисунке~\ref{fig:stats} можно увидеть усредненное время взятое со 100 экземпляров нагрузочного тестирования соответствующего типа за 100 итераций, выполнявшихся в одно и тоже время. По вертикали указано время в миллисекундах, в свою очередь, по горизонтали номер итерации.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{averaged-statistics.jpg}
    \caption{\label{fig:stats}Статистика по Comet и WebSocket соединениям}
\end{figure}

Как можно видеть на графике, время между полученными сообщениями для  Comet и WebSocket соединений существенно разнится. Данный результат объясняется тем, что для Comet соединения клиентская сторона после каждого полученного сообщения вынужденна переподписываться для получения следующих сообщений, тем самым снова и снова отправляя, кроме необходимой информации, основные HTTP заголовки, тем самым увеличивая объем передаваемых данных. Однако в случае использования WebSocket протокола, после установления двунаправленного соединения между сервером и клиентом, никаких переподписок не происходит, а также не происходит отправка тяжеловесных HTTP заголовков вместе с исходным сообщением, тем самым уменьшая объем передаваемых данных.



\section{Заключение}
В ходе данной работы были изучены основы архитектуры NodeJS и NGINX, также были рассмотрены основные способы асинхронного обмена данными между клиентом и сервером. На основе этих данных было создано приложение, позволяющее обмениваться данными между клиентами и сервером в режиме реального времени, а также в достаточной мере устойчивое к высоким нагрузкам (к большому числу одновременно подключенных клиентов). Кроме этого по результатам нагрузочного тестирования удалось выяснить, что передача данных с использованием WebSocket протокола является наиболее оптимальной для двунаправленной передачи данных.

\bibliographystyle{gost780uv} 
\bibliography{my}
\newpage
\appendix


\section{Листинг Comet сервера, написанного на JavaScript}\label{listing-nod-1}
Код приложения \verb"comet-server.js".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{comet-server.js}



\section{Листинг WebSocket сервера, написанного на JavaScript}\label{listing-nod-2}
Код приложения \verb"ws-server.js".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{ws-server.js}


\section{Листинг Static сервера, написанного на JavaScript}\label{listing-nod-3}
Код приложения \verb"static-server.js".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{static-server.js}


\section{Листинг Messaging сервиса, написанного на JavaScript}\label{listing-nod-4}
Код приложения \verb"server-helper-util.js".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{server-helper-util.js}


\section{Листинг с кодом для Gulp task runner, написанного на JavaScript}\label{listing-nod-5}
Код приложения \verb"gulpfile.js".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{gulpfile.js}


\section{Конфигурационный файл NGINX}\label{listing-nod-6}
Код приложения \verb"nginx.conf".

\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{nginx.conf}



\section{Содержимое диска и инструкция для запуска}\label{listing-nod-7}

Содержимое диска включает в себя следующие компоненты:
\begin{enumerate}
\item папка \verb|config| содержит настройки для логгера приложения;
\item папка \verb|logs| содержит в себе файлы логов с информацией о работе приложения;
\item папка \verb|nginx-1.8.0| содержит NGINX сервер;
\item папка \verb|public| содержит пользовательский интерфейс;
\item файл \verb|readme.txt| содержит инструкции для установки и запуска приложения и нагрузочных тестов;
\item файл \verb|comet-server.js| содержит код для comet сервера;
\item файл \verb|ws-server.js| содержит код для websocket сервера;
\item файл \verb|static-server.js| содержит код для static сервера;
\item файл \verb|server-helper-util.js| содержит код для messaging сервиса;
\item файл \verb|gulpfile.js| содержит код для gulp task runner;
\item файлы \verb|test-comet.js| и  \verb|test-comet-send.js| содержат код нагрузочного тестирования comet соединения;
\item файл \verb|test-comet-send.js| ;
\item файл \verb|test-ws.js| и \verb|test-ws-send.js| содержат код для нагрузочного тестирования websocket соединения;
\item файл \verb|test-helper-util.js| содержит код для сохранения данных о нагрузочном тестировании;
\item файл \verb|package.json| содержит список nodejs модулей, которые необходимо установить после запуска \verb|npm install.bat|;
\item файл \verb|gulp-serve.bat| содержит набор команд для запуска приложения;
\item файл \verb|gulp-test-comet.bat| содержит набор команд для запуска нагрузочного тестирования comet соединения;
\item файл \verb|gulp-test-ws.bat| содержит набор команд для запуска нагрузочного тестирования webcocket соединения;
\item файл \verb|npm install global.bat| содержит набор команд для установки глобальных nodejs модулей;
\item файл \verb|npm install.bat| содержит набор команд для установки локальных nodejs модулей;
\item файл \verb|restart-nginx.bat| содержит набор команд для перезапуска NGINX сервера;
\item файл \verb|stor-nginx.bat| содержит набор команд для остановки NGINX сервера .
\end{enumerate}


Инструкция для запуска приложения и нагрузочных тестов:
\begin{enumerate}
\item https://git-scm.com/downloads установить систему версионного контроля git 
\item https://nodejs.org/en/ установить последнюю версию nodejs
\item убедитесь, что в системной переменной path прописаны следующие пути:
\begin{itemize}
\item "C:\textbackslash Program Files \textbackslash nodejs \textbackslash" 
\item "C:\textbackslash Files\textbackslash Git\textbackslash cmd" 
\item "C:\textbackslash Users\textbackslash USERPROFILE\textbackslash AppData\textbackslash Roaming\textbackslash npm"
\end{itemize}
где USERPROFILE --- имя пользователя
		
\item запустить "npm install global.bat", чтобы установить команду gulp глобально
\item запустить "npm install.bat", чтобы установить nodejs модули, необходимые для работы приложения
\item запустить "gulp-serve.bat", чтобы запустить приложение
\item открыть "gulp-test-comet.bat" для запуска нагрузочных тестов comet соединения
\item открыть "gulp-test-ws.bat" для запуска нагрузочных тестов websocket соединения
\end{enumerate}

Вышеперечисленные действия необходимо проводить под профилем администратора.

%\section{Листинг античного алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-1}
%Код приложения \verb"obalg.cpp".

%\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{obalg.txt}



%Курсовая работа по теме <<Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного>>   выполнена мною самостоятельно и на все источники даны соответствующие ссылки.

\end{document}
