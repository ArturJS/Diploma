\documentclass[bachelor, och, diploma, times]{SCWorks} 
% параметр - тип обучения - одно из значений: 
% spec - специальность 
% bachelor - бакалавриат (по умолчанию) 
% master - магистратура 
% параметр - форма обучения - одно из значений: 
% och - очное (по умолчанию) 
% zaoch - заочное 
% параметр - тип работы - одно из значений: 
% referat - реферат 
% coursework - курсовая работа (по умолчанию) 
% diploma - дипломная работа 
% pract - отчет по практике 
% параметр - включение шрифта 
% times - включение шрифта Times New Roman (если установлен) 
% по умолчанию выключен 
\usepackage[T2A]{fontenc} 
\usepackage[cp1251]{inputenc} 
\usepackage{graphicx} 

\usepackage[sort,compress]{cite} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{fancyvrb} 
\usepackage{longtable} 
\usepackage{array} 
\usepackage[english,russian]{babel} 
\usepackage{tikz} 


\usepackage[colorlinks=false]{hyperref} 

\newcommand{\eqdef}{\stackrel {\rm def}{=}} 

\newtheorem{lem}{Лемма} 

\begin{document} 

% Кафедра (в родительном падеже) 
\chair{математической кибернетики и компьютерных наук} 

% Тема работы 
%\title{Разработка приложения на языке C++ в среде Microsoft VisualStudio} 
\title{Разработка высоконагруженных приложений на языке JavaScript.} 

% Курс 
\course{4} 

% Группа 
\group{411} 

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ") 
%\department{факультета КНиИТ} 

% Специальность/направление код - наименование 
\napravlenie{02.03.02 "-— Фундаментальная информатика и информационные технологии} 
%\napravlenie{010500 "-— Математическое обеспечение и администрирование информационных систем} 
%\napravlenie{230100 "-— Информатика и вычислительная техника} 
%\napravlenie{231000 "-— Программная инженерия} 
%\napravlenie{090301 "-— Компьютерная безопасность} 

% Для студентки. Для работы студента следующая команда не нужна. 
\studenttitle{Студента} 

% Фамилия, имя, отчество в родительном падеже 
\author{Низамутдинова Артура Салаватовича} 

% Заведующий кафедрой 
\chtitle{к.ф.-м.н.} % степень, звание 
\chname{С.~В.~Миронов} 

%Научный руководитель (для реферата преподаватель проверяющий работу) 
\satitle{доцент} %должность, степень, звание 
\saname{И.~А.~Борзов} 

% Руководитель практики от организации (только для практики, 
% для остальных типов работ не используется) 
\patitle{доцент} 
\paname{И.~А.~Борзов} 

% Семестр (только для практики, для остальных 
% типов работ не используется) 
\term{8} 

% Наименование практики (только для практики, для остальных 
% типов работ не используется) 
\practtype{преддипломная} 

% Продолжительность практики (количество недель) (только для практики, 
% для остальных типов работ не используется) 
\duration{4} 

% Даты начала и окончания практики (только для практики, для остальных 
% типов работ не используется) 
\practStart{06.05.2016} 
\practFinish{02.06.2016} 

% Год выполнения отчета 
\date{2016} 

\maketitle 

% Включение нумерации рисунков, формул и таблиц по разделам 
% (по умолчанию - нумерация сквозная) 
% (допускается оба вида нумерации) 
%\secNumbering 


\tableofcontents 

% Раздел "Обозначения и сокращения". Может отсутствовать в работе 
%\abbreviations 

% Раздел "Определения". Может отсутствовать в работе 
%\definitions 

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе. 
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения" 
%\defabbr

% Раздел "Введение"
\intro
В 2009 году Райан Дал после двух лет экспериментирования над созданием серверных веб-компонентов разработал NodeJS.

NodeJS является программной платформой, основанной на разработанном компанией Google JavaScript --- движке V8 (транслирующем JavaScript в машинный код), преобразующий JavaScript из узкоспециализированного в язык общего назначения. NodeJS используется преимущественно на сервере, выполняя роль веб-сервера, но кроме этого есть возможность разрабатывать на NodeJS и десктопные приложения (с использованием NW.js, Electron или AppJS  для Windows, Linux и Mac OS)  и даже программировать микроконтроллеры (например, espruino и tessel). Также важно отметить, что NodeJS используют в своих проектах такие крупные компании как Google, Yahoo, PayPal, Yammer и многие другие.



%Целью настоящей работы является приведение примеров, а также сравнение эффективности алгоритмов для нахождения $\nod$ и $\nok$ двух натуральных чисел.

Поставленные задачи:
\begin{itemize}
    \item изучить архитектуру NodeJS и NGINX;
    \item рассмотреть способы асинхронного обмена данными с сервером с использованием websocket, comet, iframe и jsonp;
    \item реализовать веб-сервер на websocket и comet;
    \item настроить NGINX как прокси-сервер и балансировщик нагрузки;
    \item провести нагрузочное тестирование comet и websocket соединений и сделать выводы.
\end{itemize}

%Также на рисунках 1, 3, 5, 7 будут представлены блок-схемы описанных ниже алгоритмов, а на рисунках 2, 4, 6, 8
%скриншоты работы программ. При этом на рисунке 9 будет показана диаграмма времени работы каждой программы на разных наборах вводимых данных.


\section{Краткое описание архитектуры NodeJS}
В основе NodeJS лежит выполнение приложения в одном программном потоке, а также асинхронная обработка всех событий. При запуске NodeJS-приложения создается единственный программный поток. NodeJS-приложение выполняется в этом потоке в ожидании, что некое приложение сделает запрос. Когда NodeJS-приложение получает запрос, то никакие другие запросы не обрабатываются до тех пор, пока не завершится обработка текущего запроса.

На первый взгляд, все это кажется не очень эффективным, если бы не то обстоятельство, что NodeJS работает в асинхронном режиме, используя цикл обработки событий и функции обратного вызова. Цикл обработки событий просто опрашивает конкретные события и в нужное время вызывает обработчики событий. В NodeJS таким обработчиком событий является функция обратного вызова.

В отличие от других однопоточных приложений, когда к NodeJS - приложению делается запрос, оно должно, в свою очередь, запросить какие-то ресурсы (например, получить доступ к файлу или обратиться к базе данных). В этом случае NodeJS инициирует запрос но не ожидает ответа на этот запрос. Вместо этого запросу назначается некая функция обратного вызова. Когда запрошенное значение будет готово (или завершено) генерируется событие, активизирующее соответствующую функцию обратного вызова, призванную что-то сделать либо с результатами запрошенного действия, либо с запрошенными ресурсами.

Если несколько человек обращаются к NodeJS-приложению в одно и то же время и приложению нужно обратиться к ресурсам из файла, для каждого запроса NodeJS назначает свою функцию обратного вызова событию ответа. Когда для каждого из них ресурс становится доступен, вызывается нужная функция обратного вызова, и запрос удовлетворяется. В промежутке NodeJS-приложение может обрабатывать другие запросы либо для того же приложения, либо для какого-нибудь другого.

Хотя приложение не обрабатывает запросы в параллельном режиме, в зависимости от своей загруженности и конструкции можно даже не заметить задержки в ответе. А что лучше всего, приложение очень экономно относится к памяти и к другим ограниченным ресурсам.\cite{nodejs}

\section{Краткое описание архитектуры NGINX}

NGINX (сокращение от engine x) --- это HTTP-сервер и обратный прокси-сервер, почтовый, а также TCP/UDP прокси-сервер общего назначения, изначально написанный Игорем Сысоевым. 

Для лучшего представления устройства, сперва необходимо понять как NGINX запускается. У NGINX есть один мастер-процесс (который от имени суперпользователя выполняет такие операции, как открытие портов и чтение конфигурации), а также некоторое количество рабочих и вспомогательных процессов. Например, на 4-х ядерном сервере мастер-процесс NGINX создает 4 рабочих процесса и пару вспомогательных кэш-процессов, которые в свою очередь управляют содержимым кэша на жестком диске.

Говоря о многопоточности важно отметить, что любой процесс или поток --- это набор самодостаточных инструкций, который операционная система может запланировать для выполнения на ядре процессора. Большинство сложных приложений параллельно запускают множество процессов или потоков по двум причинам:
\begin{enumerate}
\item Чтобы одновременно задействовать больше вычислительных ядер;
\item Процессы и потоки позволяют проще выполнять параллельные операции (например работать с множеством соединений одновременно).
\end{enumerate}

\subsection{Несколько слов о важности архитектуры}

Процессы и потоки сами по себе расходуют дополнительные ресурсы. Каждый из процессов или потоков потребляет некоторое количество памяти, и кроме того постоянно подменяют друг друга на процессоре (так называемое переключение контекста). Современные серверы могут справляться с сотнями активных процессов и потоков, но производительность сильно падает, как только заканчивается память или огромное количество операций ввода-вывода приводит к слишком частой смене контекста.

Наиболее типичный подход к построению сетевого приложения --- это выделять для каждого соединения отдельный процесс или поток. Такая архитектура действительно проста для понимания и легка в реализации, но при этом плохо масштабируется, когда приложению приходится работать с тысячами соединений одновременно.\cite{Nginx}

\subsection{Основные моменты работы NGINX}

В NGINX используется архитектура с предварительно заданным числом процессов, которая эффективней всего использует имеющиеся системные ресурсы:

\begin{itemize}
\item Мастер-процесс запускает команды, требующие повышенных прав доступа, такие как открытие портов и чтение конфигурации, после чего порождает несколько дочерних процессов (следующих трех типов).
\item Загрузчик кэша начинает свою работу на старте, для того чтобы загрузить данные кэша, находящиеся на диске, в оперативную память, и затем завершается. Его работа рассчитана таким образом, чтобы потреблять как можно меньше ресурсов.
\item Кэш-менеджер периодически активируется, чтобы удалить данные кэша с жесткого диска, таким образом, поддерживая его объем в заранее заданных границах.
\item Рабочие процессы выполняют основную часть работы. Они работают с сетевыми соединениями, читая и записывая данные на диск, обмениваются данными с бэкенд-серверами.\cite{Nginx}
\end{itemize}

\subsection{Внутри рабочего процесса}

Каждый рабочий процесс NGINX инициализируется с заданной конфигурацией и набором слушающих сокетов, унаследованных от мастер-процесса.

Рабочие процессы начинают с ожидания событий на слушающих сокетах. События извещают о новых соединениях. Эти соединения попадают в конечный автомат --- наиболее часто используемый предназначен для обработки HTTP, но NGINX также содержит конечные автоматы для обработки потоков TCP трафика (модуль stream) и целого ряда протоколов электронной почты (SMTP, IMAP и POP3).

Конечный автомат в NGINX по своей сути является набором инструкций для обработки запроса. Большинство веб-серверов выполняют такую же функцию, но разница кроется в реализации.\cite{Nginx}

\subsection{Устройство конечного автомата}
Конечный автомат можно представить себе в виде правил для игры в шахматы. Каждая HTTP транзакция — это шахматная партия. С одной стороны шахматной доски веб-сервер — гроссмейстер, который принимает решения очень быстро. На другой стороне — удаленный клиент, браузер, который запрашивает сайт или приложение по относительно медленной сети.

Как бы то ни было, правила игры могут быть очень сложными. Например, веб-серверу может потребоваться взаимодействовать с другими ресурсами (проксировать запросы на бэкенд) или обращаться к серверу аутентификации. Сторонние модули способны ещё сильнее усложнить обработку.\cite{Nginx}

\subsection{Блокирующийся конечный автомат}

Вспомните наше определение процесса или потока, как самодостаточного набора инструкций, выполнение которых операционная система может назначать на конкретное ядро процессора. Большинство веб-серверов и веб-приложений используют модель, в которой для «игры в шахматы» приходится по одному процессу или потоку на соединение. Каждый процесс или поток содержит инструкции, чтобы сыграть одну партию до конца. Все это время процесс, выполняясь на сервере, проводит большую часть времени заблокированным в ожидании следующего хода от клиента.

\begin{enumerate}
\item Процесс веб-сервера ожидает новых соединений (новых партий инициированных клиентами) на слушающих сокетах.
\item Получив новое соединение, он играет партию, блокируясь после каждого хода в ожидании ответа от клиента.
\item Когда партия сыграна, процесс веб-сервера может находиться в ожидании желания клиента начать следующую партию (это соответствует долгоживущим keepalive-соединениям). Если соединение закрыто (клиент ушел или наступил таймаут), процесс возвращается к встрече новых клиентов на слушающих сокетах.
\end{enumerate}

Важный момент, который стоит отметить, заключается в том, что каждое активное HTTP-соединение (каждая партия) требует отдельного процесса или потока (гроссмейстера). Такая архитектура проста и легко расширяема с помощью сторонних модулей (новых «правил»). Однако, в ней существует огромный дисбаланс: достаточно легкое HTTP-соединение, представленное в виде файлового дескриптора и небольшого объема памяти, соотносится с отдельным процессом или потоком, достаточно тяжелым объектом в операционной системе. Это удобно для программирования, но весьма расточительно.\cite{Nginx}

\section{Способы асинхронного обмена данными с сервером}
В современном Web асинхронный обмен данными с сервером является практически его неотъемлемой частью. Подобный обмен данными позволяет без перезагрузки страницы клиентского приложения обмениваться различной информацией с сервером, что в свою очередь позволяет как повысить интерактивность web-приложений, так и дает возможность обмена данными в режиме реального времени с сервером. 

В далее качестве примеров рассмотрим способы обмена данными с использованием websocket, comet, iframe и jsonp.

\subsection{WebSocket}
WebSocket протокол был утвержден в качестве стандарта RFC 6455 в декабре 2011 года. 
Данный тип соединения предоставляет двунаправленное полнодуплексное соединение.
С помощью WebSocket можно создавать интерактивные браузерные веб-приложения, которые постоянно обмениваются данными с сервером, но при этом не нуждаются в открытии нескольких HTTP-соединений.

Хоть и WebSocket использует HTTP как основной механизм для передачи данных, однако канал связи не закрывается после получения данных клиентом. Используя WebSocket API вы полностью свободны от ограничений типичного цикла HTTP (request/responce). Это также означает, что до тех пор пока соединение остается открытым, клиент и сервер могут свободно отправлять данные в асинхронном режиме без опроса для чего-нибудь нового.\cite{ws}

Цикл работы WebSocket соединения состоит из следующих этапов:

\begin{itemize}
    \item установления соединения (opening handshake);
    \item оформления и отправки данных;
    \item закрытие соединения (closing handshake).
\end{itemize}

\subsubsection{Установление WebSocket соединения}
Поскольку протокол WebSocket работает поверх HTTP, то это означает, что при подключении браузер отправляет следующие специальные заголовки:

\begin{verbatim}
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 13
\end{verbatim}


 Описание заголовков:
 
 
       \verb!GET, Host! --- стандартные HTTP---заголовки из URL запроса.

        \verb!Upgrade, Connection! --- указывают, что браузер хочет перейти на websocket.
     
        \verb!Origin! --- протокол, домен и порт, откуда отправлен запрос.

        \verb!Sec-WebSocket-Key! --- случайный ключ, который генерируется браузером: 16 байт в кодировке Base64.

        \verb!Sec-WebSocket-Version! --- версия протокола. Текущая версия: 13.
        
        Все заголовки, кроме \verb!GET! и \verb!Host!, браузер генерирует сам, без возможности вмешательства JavaScript.
        
        
Далее сервер, проанализировав эти заголовки, решает, разрешает ли он соединение WebSocket с данного домена \verb!Origin!.

 В случае, если сервер разрешает WebSocket подключение, то он возвращает клиенту ответ следующего вида:
 \begin{verbatim}
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
 \end{verbatim}
 

Здесь заголовок \verb!Sec-WebSocket-Accept! представляет собой перекодированный с использование специального алгоритма ключ \verb!Sec-WebSocket-Key!. Браузер в свою очередь использует ее для проверки, что ответ предназначается именно ему.

Затем данные передаются по специальному протоколу, структура которого (<<фреймы>>) изложена далее. И это уже совсем не HTTP.\cite{ws}

\subsubsection{Оформление и передача данных с использованием WebSocket протокола}

В протоколе WebSocket предусмотрены несколько видов пакетов (<<фреймов>>).

Они делятся на два больших типа: фреймы с данными (<<data frames>>) и управляющие (<<control frames>>), предназначенные для проверки связи (PING) и закрытия соединения.

На рисунке~\ref{fig:wsframe} можно увидеть общий вид WebSocket фрейма, согласно его стандарту.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{WebSocket-frame.png}
    \caption{\label{fig:wsframe}Схема WebSocket фрейма}
    \end{figure}

\subsubsection{Закрытие WebSocket соединения}
Процесс закрытия WebSocket соединения гораздо проще, чем процесс открытия.

Любая из сторон WebSocket соединения может отправить управляющий фрейм с данными содержащими специальную управляющую последовательность для начала процесса закрытия. После отправки управляющего фрейма, указывающего, что соединение должно быть закрыто, другая сторона в дальнейшем отбрасывает любые данные, которые были отправлены.
В добавок ко всему выше сказанному, процесс закрытия WebSocket соединения безопасен для одновременной инициализации обеими сторонами.\cite{ws2}



\subsection{Comet}
Другое название метода --- <<Очередь ожидающих запросов>>. 

Основа работы данного метода состоит из следующей последовательности шагов:
\begin{itemize}
    \item Отправляется запрос на сервер
    \item Соединение не закрывается сервером пока не появится событие;
    \item Событие отправляется в ответ на запрос;
    \item Клиент тут же отправляет новый ожидающий запрос.
\end{itemize}

Ситуация, когда браузер отправляет запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.

При этом в случае, когда соединение рвется само, к примеру, из-за ошибки в сети, то браузер тут же отсылает новый запрос.\cite{comet}

\subsection{IFrame}

По сути IFrame представляет собой окно браузера, вложенное в основное окно.  

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается невидимый IFrame на специальный URL;
    \item При наступлении событий на сервере в IFrame тут же поступает тег \verb!<script>! --- пакет с данными вида:
    \begin{verbatim}
<script>
parent.handleMessage({txt:"Hello",time:123456789})
</script>
     \end{verbatim} 
    \item Соединение закрывается в случаях:
    \begin{itemize}
        \item при возникновении ошибки;
        \item каждые 20---30 секунд;
        \item когда требуется очистка памяти от старых сообщений (время от времени создаем новый IFrame и удаляем старый).
    \end{itemize}
\end{enumerate}

На рисунке~\ref{fig:iframe} можно увидеть схему работы IFrame транспорта.\cite{iframe}


    \begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{iframe.png}
    \caption{\label{fig:iframe}Общая схема работы IFrame транспорта}
    \end{figure}

\subsection{JSONP}

Если попробовать создать тег \verb!<script src>!, то при добавлении его в документ запустится процесс загрузки с данного \verb!src!. В ответ на запрос сервер может прислать скрипт, который будет содержать нужные данные.

С помощью данного способа можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.

Протокол JSONP --- это своего рода надстройка над таким способом коммуникации.

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается тег \verb!<script>! на специальный URL, в котором в качестве параметра передается имя функции обратного вызова, которая будет вызываться при получении данных;
    \item В свою очередь сервер формирует ответ в виде вызова этой функции с данными переданными в ней в качестве параметров, и отправляет ответ клиенту;
    \item Сразу после того как клиентская сторона получает ответ от сервера, полученный скрипт начинает немедленно выполняться, таким образом вызывая функцию обратного вызова, которая располагается на стороне клиента.
\end{enumerate}

При использовании данного метода необходимо помнить про аспект безопасности, поскольку клиентский код должен доверять серверу при таком способе запроса данных. Ведь серверу ничего не стоит добавить в скрипт любые вредоносные команды.

COMET через протокол JSONP реализуется с использованием длинных запросов, то есть, создается тег \verb!<script>!, браузер запрашивает скрипт у сервера и сервер оставляет соединение висеть, пока не появятся данные, которые необходимо передать клиенту. Когда сервер хочет отправить сообщение --- он формирует ответ с использованием формата JSONP, и тут же клиент отправляет новый запрос.\cite{jsonp}

\section{Описание архитектуры приложения}
Архитектура приложения состоит из следующих компонентов:
\begin{itemize}
\item NGINX (прокси-сервер и балансировщик нагрузки)
\item 2 WebSocket сервера
\item 2 Comet сервера
\item Messaging сервис
\end{itemize}

На рисунке~\ref{fig:cluster} можно увидеть общую схему приложения.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{Architecture.png}
    \caption{\label{fig:cluster}Архитектура приложения}
\end{figure}

\subsection{Цикл работы приложения}
После развертывания приложения, пользователи получают UI функционал (html + css + javascript), с помощью которого предоставляется возможность выбрать протокол, через который будет проходить обмен данными с сервером (в данном случае пользователь отправляет координаты своего местоположения с определенным интервалом). В ситуации, если пользователь выбрал WebSocket соединение, то NGINX, используя директиву \verb!least_conn!, перенаправляет запрос на активацию соединения к тому WebSocket серверу, который в текущий момент имеет наименьшее число подключений. Однако, если пользователь выбрал Comet соединение, то в этом случае NGINX, используя директиву \verb!ip_hash!, создает специальный хеш для ip адреса пользователя, чтобы все последующие запросы шли на изначально определенный Comet сервер. В дальнейшем сообщение переотправляется всем подписчикам данного экземпляра сервера, а также передается в Messaging сервис, который в свою очередь пересылает сообщение другим экземплярам серверов кластера. Далее эти экземпляры пересылают это сообщение для своих подписчиков.

\section{Нагрузочное тестирование Comet и WebSocket соединений}
Для тестирования Comet и WebSocket соединений также были созданы 2 программы, которые можно запустить, открыв \verb!gulp-test-comet.bat! или \verb!gulp-test-ws.bat! для тестирования соответствующего типа соединения. Перед тестированием не забудьте открыть \verb!gulp-serve.bat! для запуска приложения. Данные \verb!.bat! файлы содержат команды \verb!gulp test-comet --i 100! и \verb!gulp test-ws --i 100!, запускающие 100 NodeJS процессов, которые в свою очередь подключаются к приложению и начинают получать сообщения от процесса-отправителя (\verb!test-comet-send.js! и \verb!test-ws-send.js! для comet и websocket соединения соответственно). Процесс-отправитель отправляет сообщения длиной 16 символов в кодировке $UTF-8$ с интервалом в несколько миллисекунд.
На рисунке~\ref{fig:stats} можно увидеть усредненное время взятое со 100 экземпляров нагрузочного тестирования соответствующего типа за 100 итераций, выполнявшихся в одно и тоже время. По вертикали указано время в миллисекундах, в свою очередь, по горизонтали номер итерации.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{averaged-statistics.jpg}
    \caption{\label{fig:stats}Статистика по Comet и WebSocket соединениям}
\end{figure}

Как можно видеть на графике, время между полученными сообщениями для  Comet и WebSocket соединений существенно разнится. Данный результат объясняется тем, что для Comet соединения клиентская сторона после каждого полученного сообщения вынужденна переподписываться для получения следующих сообщений, тем самым снова и снова отправляя, кроме необходимой информации, основные HTTP заголовки, тем самым увеличивая объем передаваемых данных. Однако в случае использования WebSocket протокола, после установления двунаправленного соединения между сервером и клиентом, никаких переподписок не происходит, а также не происходит отправка тяжеловесных HTTP заголовков вместе с исходным сообщением, тем самым уменьшая объем передаваемых данных.



\section{Выводы}
В ходе данной работы были изучены основы архитектуры NodeJS и NGINX, также были рассмотрены основные способы асинхронного обмена данными между клиентом и сервером. На основе этих данных было создано приложение, позволяющее обмениваться данными между клиентами и сервером в режиме реального времени, а также в достаточной мере устойчивое к высоким нагрузкам (к большому числу одновременно подключенных клиентов). Кроме этого удалось выяснить, что передача данных с использованием WebSocket протокола является наиболее оптимальной для двунаправленной передачи данных.

\bibliographystyle{gost780uv} 
\bibliography{my}
\newpage
%\section{Листинг античного алгоритма Евклида, написанного на Microsoft Visual Studio C++ 2010}\label{listing-nod-1}
%Код приложения \verb"obalg.cpp".

%\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{obalg.txt}


%\section{Таблица}
%\begin{table}[!ht]
%	\footnotesize
%	\caption{Results of pass-fail dictionary reduction with the help
%	of masks} \label{table-2}
%	\begin{tabular}{|p{1.5cm}|
	%                 p{1.5cm}|
%	                 p{1.5cm}|
%	               p{1.5cm}|
%	                 p{1cm}|}
%		\hline \centering Circuit & Number of modelled faults & Number of test
%		vectors in the test set & The volume of pass-fail dictionary,
%		\linebreak bit & The volume of found mask
%		\\
%		\hline S298 & 177 & 322 & 56994 & 30 & 5310 & 9,32\% & 0,07\\
%		\hline S344 & 240 & 127 & 30480 & 29 & 6960 & 22,83\% & 0,04\\
%		\hline S349 & 243 & 134 & 32562 & 35 & 8505 & 26,12\% & 0,05\\
%		\hline S382 & 190 & 2074 & 394060 & 28 & 5320 & 1,35\% & 0,43\\
%		\hline S386 & 274 & 286 & 78364 & 65 & 17810 & 22,73\% & 0,26\\
%		\hline S400 & 194 & 2214 & 429516 & 32 & 6208 & 1,45\% & 0,99\\
%		\hline S444 & 191 & 2240 & 427840 & 30 & 5730 & 1,34\% & 0,98\\
%		\hline S526 & 138 & 2258 & 311604 & 28 & 3864 & 1,24\% & 0,61\\
%		\hline S641 & 345 & 209 & 72105 & 58 & 20010 & 27,75\% & 0,24\\
%		\hline S713 & 343 & 173 & 59339 & 58 & 19894 & 33,53\% & 0,19\\
%		\hline S820 & 712 & 1115 & 793880 & 147 & 104664 & 13,18\% & 9,09\\
%		\hline S832 & 719 & 1137 & 817503 & 151 & 108569 & 13,28\% & 9,20\\
%		\hline S953 & 326 & 14 & 4564 & 13 & 4238 & 92,86\% & 0,01\\
%		\hline S1423 & 293 & 150 & 43950 & 58 & 16994 & 38,67\% & 0,15\\
%		\hline S1488 & 1359 & 1170 & 1590030 & 158 & 214722 & 13,50\% & 26,69\\
%		\hline
%	\end{tabular}
%\end{table}
%\newpage
%\centering
%Курсовая работа по теме <<Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного>>   выполнена мною самостоятельно и на все источники даны соответствующие ссылки.

\end{document}
