\documentclass[bachelor, och, autoref, times]{SCWorks} 
% параметр - тип обучения - одно из значений: 
% spec - специальность 
% bachelor - бакалавриат (по умолчанию) 
% master - магистратура 
% параметр - форма обучения - одно из значений: 
% och - очное (по умолчанию) 
% zaoch - заочное 
% параметр - тип работы - одно из значений: 
% referat - реферат 
% coursework - курсовая работа (по умолчанию) 
% diploma - дипломная работа 
% pract - отчет по практике 
% параметр - включение шрифта 
% times - включение шрифта Times New Roman (если установлен) 
% по умолчанию выключен 
\usepackage[T2A]{fontenc} 
\usepackage[cp1251]{inputenc} 
\usepackage{graphicx} 

\usepackage[sort,compress]{cite} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{fancyvrb} 
\usepackage{longtable} 
\usepackage{array} 
\usepackage[english,russian]{babel} 
\usepackage{tikz} 


\usepackage[colorlinks=false]{hyperref} 

\newcommand{\eqdef}{\stackrel {\rm def}{=}} 

\newtheorem{lem}{Лемма} 

\begin{document} 

% Кафедра (в родительном падеже) 
\chair{математической кибернетики и компьютерных наук} 

% Тема работы 
%\title{Разработка приложения на языке C++ в среде Microsoft VisualStudio} 
\title{Разработка высоконагруженных приложений на языке JavaScript.} 

% Курс 
\course{4} 

% Группа 
\group{411} 

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ") 
%\department{факультета КНиИТ} 

% Специальность/направление код - наименование 
\napravlenie{02.03.02 "-— Фундаментальная информатика и информационные технологии} 
%\napravlenie{010500 "-— Математическое обеспечение и администрирование информационных систем} 
%\napravlenie{230100 "-— Информатика и вычислительная техника} 
%\napravlenie{231000 "-— Программная инженерия} 
%\napravlenie{090301 "-— Компьютерная безопасность} 

% Для студентки. Для работы студента следующая команда не нужна. 
\studenttitle{Студента} 

% Фамилия, имя, отчество в родительном падеже 
\author{Низамутдинова Артура Салаватовича} 

% Заведующий кафедрой 
\chtitle{к.ф.-м.н.} % степень, звание 
\chname{С.~В.~Миронов} 

%Научный руководитель (для реферата преподаватель проверяющий работу) 
\satitle{доцент} %должность, степень, звание 
\saname{И.~А.~Борзов} 

% Руководитель практики от организации (только для практики, 
% для остальных типов работ не используется) 
\patitle{доцент} 
\paname{И.~А.~Борзов} 

% Семестр (только для практики, для остальных 
% типов работ не используется) 
\term{8} 

% Наименование практики (только для практики, для остальных 
% типов работ не используется) 
\practtype{преддипломная} 

% Продолжительность практики (количество недель) (только для практики, 
% для остальных типов работ не используется) 
\duration{4} 

% Даты начала и окончания практики (только для практики, для остальных 
% типов работ не используется) 
\practStart{06.05.2016} 
\practFinish{02.06.2016} 

% Год выполнения отчета 
\date{2016} 

\maketitle 

% Включение нумерации рисунков, формул и таблиц по разделам 
% (по умолчанию - нумерация сквозная) 
% (допускается оба вида нумерации) 
%\secNumbering 


%\tableofcontents 

% Раздел "Обозначения и сокращения". Может отсутствовать в работе 
%\abbreviations 

% Раздел "Определения". Может отсутствовать в работе 
%\definitions 

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе. 
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения" 
%\defabbr

% Раздел "Введение"
\intro
В 2009 году Райан Дал после двух лет экспериментирования над созданием серверных веб-компонентов разработал NodeJS.

NodeJS является программной платформой, основанной на разработанном компанией Google JavaScript --- движке V8 (транслирующем JavaScript в машинный код), преобразующий JavaScript из узкоспециализированного в язык общего назначения. NodeJS используется преимущественно на сервере, выполняя роль веб-сервера, но кроме этого есть возможность разрабатывать на NodeJS и десктопные приложения (с использованием NW.js, Electron или AppJS  для Windows, Linux и Mac OS)  и даже программировать микроконтроллеры (например, espruino и tessel). Также важно отметить, что NodeJS используют в своих проектах такие крупные компании как Google, Yahoo, PayPal, Yammer и многие другие.



%Целью настоящей работы является приведение примеров, а также сравнение эффективности алгоритмов для нахождения $\nod$ и $\nok$ двух натуральных чисел.

Поставленные задачи:
\begin{itemize}
    \item изучить архитектуру NodeJS и NGINX;
    \item рассмотреть способы асинхронного обмена данными с сервером с использованием websocket, comet, iframe и jsonp;
    \item реализовать веб-сервер на websocket и comet;
    \item настроить NGINX как прокси-сервер и балансировщик нагрузки;
    \item провести нагрузочное тестирование comet и websocket соединений и сделать выводы.
\end{itemize}

%Также на рисунках 1, 3, 5, 7 будут представлены блок-схемы описанных ниже алгоритмов, а на рисунках 2, 4, 6, 8
%скриншоты работы программ. При этом на рисунке 9 будет показана диаграмма времени работы каждой программы на разных наборах вводимых данных.


\section{Краткое описание архитектуры NodeJS}
В основе NodeJS лежит выполнение приложения в одном программном потоке, а также асинхронная обработка всех событий. При запуске NodeJS-приложения создается единственный программный поток. NodeJS-приложение выполняется в этом потоке в ожидании, что некое приложение сделает запрос. Когда NodeJS-приложение получает запрос, то никакие другие запросы не обрабатываются до тех пор, пока не завершится обработка текущего запроса.

На первый взгляд, все это кажется не очень эффективным, если бы не то обстоятельство, что NodeJS работает в асинхронном режиме, используя цикл обработки событий и функции обратного вызова. Цикл обработки событий просто опрашивает конкретные события и в нужное время вызывает обработчики событий. В NodeJS таким обработчиком событий является функция обратного вызова.

В отличие от других однопоточных приложений, когда к NodeJS - приложению делается запрос, оно должно, в свою очередь, запросить какие-то ресурсы (например, получить доступ к файлу или обратиться к базе данных). В этом случае NodeJS инициирует запрос но не ожидает ответа на этот запрос. Вместо этого запросу назначается некая функция обратного вызова. Когда запрошенное значение будет готово (или завершено) генерируется событие, активизирующее соответствующую функцию обратного вызова, призванную что-то сделать либо с результатами запрошенного действия, либо с запрошенными ресурсами.

Если несколько человек обращаются к NodeJS-приложению в одно и то же время и приложению нужно обратиться к ресурсам из файла, для каждого запроса NodeJS назначает свою функцию обратного вызова событию ответа. Когда для каждого из них ресурс становится доступен, вызывается нужная функция обратного вызова, и запрос удовлетворяется. В промежутке NodeJS-приложение может обрабатывать другие запросы либо для того же приложения, либо для какого-нибудь другого.

Хотя приложение не обрабатывает запросы в параллельном режиме, в зависимости от своей загруженности и конструкции можно даже не заметить задержки в ответе. А что лучше всего, приложение очень экономно относится к памяти и к другим ограниченным ресурсам.\cite{nodejs}

\section{Краткое описание архитектуры NGINX}

NGINX (сокращение от engine x) --- это HTTP-сервер и обратный прокси-сервер, почтовый, а также TCP/UDP прокси-сервер общего назначения, изначально написанный Игорем Сысоевым. 

Для лучшего представления устройства, сперва необходимо понять как NGINX запускается. У NGINX есть один мастер-процесс (который от имени суперпользователя выполняет такие операции, как открытие портов и чтение конфигурации), а также некоторое количество рабочих и вспомогательных процессов. Например, на 4-х ядерном сервере мастер-процесс NGINX создает 4 рабочих процесса и пару вспомогательных кэш-процессов, которые в свою очередь управляют содержимым кэша на жестком диске.

Говоря о многопоточности важно отметить, что любой процесс или поток --- это набор самодостаточных инструкций, который операционная система может запланировать для выполнения на ядре процессора. Большинство сложных приложений параллельно запускают множество процессов или потоков по двум причинам:
\begin{enumerate}
\item Чтобы одновременно задействовать больше вычислительных ядер;
\item Процессы и потоки позволяют проще выполнять параллельные операции (например работать с множеством соединений одновременно).
\end{enumerate}

\subsection{Основные моменты работы NGINX}

В NGINX используется архитектура с предварительно заданным числом процессов, которая эффективней всего использует имеющиеся системные ресурсы:

\begin{itemize}
\item Мастер-процесс запускает команды, требующие повышенных прав доступа, такие как открытие портов и чтение конфигурации, после чего порождает несколько дочерних процессов (следующих трех типов).
\item Загрузчик кэша начинает свою работу на старте, для того чтобы загрузить данные кэша, находящиеся на диске, в оперативную память, и затем завершается. Его работа рассчитана таким образом, чтобы потреблять как можно меньше ресурсов.
\item Кэш-менеджер периодически активируется, чтобы удалить данные кэша с жесткого диска, таким образом, поддерживая его объем в заранее заданных границах.
\item Рабочие процессы выполняют основную часть работы. Они работают с сетевыми соединениями, читая и записывая данные на диск, обмениваются данными с бэкенд-серверами.\cite{Nginx}
\end{itemize}


\section{Способы асинхронного обмена данными с сервером}
В современном Web асинхронный обмен данными с сервером является практически его неотъемлемой частью. Подобный обмен данными позволяет без перезагрузки страницы клиентского приложения обмениваться различной информацией с сервером, что в свою очередь позволяет как повысить интерактивность web-приложений, так и дает возможность обмена данными в режиме реального времени с сервером. 

В далее качестве примеров рассмотрим способы обмена данными с использованием websocket, comet, iframe и jsonp.

\subsection{WebSocket}
WebSocket протокол был утвержден в качестве стандарта RFC 6455 в декабре 2011 года. 
Данный тип соединения предоставляет двунаправленное полнодуплексное соединение.
С помощью WebSocket можно создавать интерактивные браузерные веб-приложения, которые постоянно обмениваются данными с сервером, но при этом не нуждаются в открытии нескольких HTTP-соединений.

Хоть и WebSocket использует HTTP как основной механизм для передачи данных, однако канал связи не закрывается после получения данных клиентом. Используя WebSocket API вы полностью свободны от ограничений типичного цикла HTTP (request/responce). Это также означает, что до тех пор пока соединение остается открытым, клиент и сервер могут свободно отправлять данные в асинхронном режиме без опроса для чего-нибудь нового.\cite{ws}

Цикл работы WebSocket соединения состоит из следующих этапов:

\begin{itemize}
    \item установления соединения (opening handshake);
    \item оформления и отправки данных;
    \item закрытие соединения (closing handshake).\cite{ws2}
\end{itemize}

\subsection{Comet}
Другое название метода --- <<Очередь ожидающих запросов>>. 

Основа работы данного метода состоит из следующей последовательности шагов:
\begin{itemize}
    \item Отправляется запрос на сервер
    \item Соединение не закрывается сервером пока не появится событие;
    \item Событие отправляется в ответ на запрос;
    \item Клиент тут же отправляет новый ожидающий запрос.
\end{itemize}

Ситуация, когда браузер отправляет запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.

При этом в случае, когда соединение рвется само, к примеру, из-за ошибки в сети, то браузер тут же отсылает новый запрос.\cite{comet}

\subsection{IFrame}

По сути IFrame представляет собой окно браузера, вложенное в основное окно.  

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается невидимый IFrame на специальный URL;
    \item При наступлении событий на сервере в IFrame тут же поступает тег \verb!<script>! --- пакет с данными вида:
    \begin{verbatim}
<script>
parent.handleMessage({txt:"Hello",time:123456789})
</script>
     \end{verbatim} 
    \item Соединение закрывается в случаях:
    \begin{itemize}
        \item при возникновении ошибки;
        \item каждые 20---30 секунд;
        \item когда требуется очистка памяти от старых сообщений (время от времени создаем новый IFrame и удаляем старый).\cite{iframe}
    \end{itemize}
\end{enumerate}

На рисунке~\ref{fig:iframe} можно увидеть схему работы IFrame транспорта.


    \begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{iframe.png}
    \caption{\label{fig:iframe}Общая схема работы IFrame транспорта}
    \end{figure}

\subsection{JSONP}

Если попробовать создать тег \verb!<script src>!, то при добавлении его в документ запустится процесс загрузки с данного \verb!src!. В ответ на запрос сервер может прислать скрипт, который будет содержать нужные данные.

С помощью данного способа можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.

Протокол JSONP --- это своего рода надстройка над таким способом коммуникации.

\subsubsection{Общая схема работы}
\begin{enumerate}
    \item На клиентской стороне создается тег \verb!<script>! на специальный URL, в котором в качестве параметра передается имя функции обратного вызова, которая будет вызываться при получении данных;
    \item В свою очередь сервер формирует ответ в виде вызова этой функции с данными переданными в ней в качестве параметров, и отправляет ответ клиенту;
    \item Сразу после того как клиентская сторона получает ответ от сервера, полученный скрипт начинает немедленно выполняться, таким образом вызывая функцию обратного вызова, которая располагается на стороне клиента.
\end{enumerate}

При использовании данного метода необходимо помнить про аспект безопасности, поскольку клиентский код должен доверять серверу при таком способе запроса данных. Ведь серверу ничего не стоит добавить в скрипт любые вредоносные команды.

COMET через протокол JSONP реализуется с использованием длинных запросов, то есть, создается тег \verb!<script>!, браузер запрашивает скрипт у сервера и сервер оставляет соединение висеть, пока не появятся данные, которые необходимо передать клиенту. Когда сервер хочет отправить сообщение --- он формирует ответ с использованием формата JSONP, и тут же клиент отправляет новый запрос.\cite{jsonp}

\section{Описание архитектуры приложения}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{Architecture.png}
    \caption{\label{fig:cluster}Архитектура приложения}
\end{figure}
Архитектура приложения состоит из следующих компонентов:
\begin{itemize}
\item NGINX (прокси-сервер и балансировщик нагрузки)
\item 2 WebSocket сервера
\item 2 Comet сервера
\item Static сервер
\item Messaging сервис
\item Gulp task runner предназначенный для запуска приложения
\end{itemize}

На рисунке~\ref{fig:cluster} можно увидеть общую схему приложения.


\subsection{Цикл работы приложения}

Рабочий процесс приложения происходит в рамках следующих простых этапов:
\begin{enumerate}
\item После развертывания приложения, пользователи, в первый раз обращающиеся к нему, получают основной функционал для полноценной работы с приложением (html + css + javascript)
\item Получив интерфейс для работы с приложением, пользователю предоставляется возможность выбрать протокол, через который будет проходить обмен данными с сервером (в данном случае пользователь отправляет координаты своего местоположения с определенным интервалом).
\item В ситуации, если пользователь выбрал WebSocket соединение, то NGINX, используя директиву \verb!least_conn!, перенаправляет запрос на активацию соединения к тому WebSocket серверу, который в текущий момент имеет наименьшее число подключений.
\item Однако, если пользователь выбрал Comet соединение, то в этом случае NGINX, используя директиву \verb!ip_hash!, создает специальный хеш для ip адреса пользователя, чтобы все последующие запросы шли на изначально определенный Comet сервер.
\item В дальнейшем сообщение переотправляется всем подписчикам данного экземпляра сервера, а также передается в Messaging сервис, который в свою очередь пересылает сообщение другим экземплярам серверов кластера. Далее эти экземпляры пересылают это сообщение для своих подписчиков.
\end{enumerate}

\section{Нагрузочное тестирование Comet и WebSocket соединений}
Для тестирования Comet и WebSocket соединений также были созданы 2 программы, которые можно запустить, открыв \verb!gulp-test-comet.bat! или \verb!gulp-test-ws.bat! для тестирования соответствующего типа соединения. Перед тестированием не забудьте открыть \verb!gulp-serve.bat! для запуска приложения. Данные \verb!.bat! файлы содержат команды \verb!gulp test-comet --i 100! и \verb!gulp test-ws --i 100!, запускающие 100 NodeJS процессов, которые в свою очередь подключаются к приложению и начинают получать сообщения от процесса-отправителя (\verb!test-comet-send.js! и \verb!test-ws-send.js! для comet и websocket соединения соответственно). Процесс-отправитель отправляет сообщения длиной 16 символов в кодировке $UTF-8$ с интервалом в несколько миллисекунд.
На рисунке~\ref{fig:stats} можно увидеть усредненное время взятое со 100 экземпляров нагрузочного тестирования соответствующего типа за 100 итераций, выполнявшихся в одно и тоже время. По вертикали указано время в миллисекундах, в свою очередь, по горизонтали номер итерации.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\textwidth]{averaged-statistics.jpg}
    \caption{\label{fig:stats}Статистика по Comet и WebSocket соединениям}
\end{figure}

Как можно видеть на графике, время между полученными сообщениями для  Comet и WebSocket соединений существенно разнится. Данный результат объясняется тем, что для Comet соединения клиентская сторона после каждого полученного сообщения вынужденна переподписываться для получения следующих сообщений, тем самым снова и снова отправляя, кроме необходимой информации, основные HTTP заголовки, тем самым увеличивая объем передаваемых данных. Однако в случае использования WebSocket протокола, после установления двунаправленного соединения между сервером и клиентом, никаких переподписок не происходит, а также не происходит отправка тяжеловесных HTTP заголовков вместе с исходным сообщением, тем самым уменьшая объем передаваемых данных.



\section{Заключение}
В ходе данной работы были изучены основы архитектуры NodeJS и NGINX, также были рассмотрены основные способы асинхронного обмена данными между клиентом и сервером. На основе этих данных было создано приложение, позволяющее обмениваться данными между клиентами и сервером в режиме реального времени, а также в достаточной мере устойчивое к высоким нагрузкам (к большому числу одновременно подключенных клиентов). Кроме этого по результатам нагрузочного тестирования удалось выяснить, что передача данных с использованием WebSocket протокола является наиболее оптимальной для двунаправленной передачи данных.

\bibliographystyle{gost780uv} 
\bibliography{my}
%\newpage

%Курсовая работа по теме <<Алгоритмы для нахождения наибольшего общего делителя и наименьшего общего кратного>>   выполнена мною самостоятельно и на все источники даны соответствующие ссылки.

\end{document}
